<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/07/07/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/07/07/%E6%9D%82%E9%A1%B9/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透配置</title>
    <link href="/2022/07/05/%E6%9D%82%E9%A1%B9/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/07/05/%E6%9D%82%E9%A1%B9/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>最近买了个三个月腾讯云的云服务器，折腾了一下服务器的环境配置，费了不少精力，具体的折腾的软件有下面几个：</p><ul><li>nginx</li><li>frp</li><li>node</li></ul><h3 id="nginx配置">1 nginx配置</h3><p>配置了一下nginx的反向代理功能：</p><ul><li>从服务器一个端口代理到服务器另一个端口</li><li>从服务器端口代理到其他网站</li></ul><p>nginx还能实现负载均衡</p><p>本来想顺便配置一下内网穿透功能，但是花了点儿时间没成功，于是使用frp配置内网穿透</p><h3 id="frp配置">2 frp配置</h3><blockquote><p>内网穿透，通过访问公网IP的设备（A），访问无公网IP设备（B）。</p></blockquote><p>frp可以解决很多访问内网资源的问题，几个典型列举如下：</p><ul><li>通过ssh访问内网机器</li><li>访问内网文件</li></ul><p>访问内网文件服务配置时遇到了一些问题。浏览器对于端口可访问服务有约定，对于端口提供的异常服务，浏览器会自动阻止服务，并弹出错误界面。由于找到的解决该问题的方法都是Windows平台下对Chrome浏览器进行配置，于是换Firefox进行页面访问，最终解决问题。</p><h3 id="node更新">3 Node更新</h3><p>node更新说实话并没有死磕下去。更新到最新版node时，会出现依赖库版本过时问题，网上解决办法都是重新下载编译，于是退而求其次，选择安装稳定版的node，最终避开问题。</p><h3 id="腾讯云配置">4 腾讯云配置</h3><p>除开浏览器会对端口对应服务进行限制，腾讯的云服务器也会对可访问端口进行限制，需要手动在管理台启动端口。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础入门</title>
    <link href="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="目标">0 目标</h2><ul><li>能够知道 vue 的基本使用步骤</li><li>掌握插值表达式和 v-bind 指令的用法</li><li>能够掌握如何使用 v-on 指令绑定事件</li><li>能够使用 v-model 指令实现数据的双向绑定</li><li>能够使用 v-if 和 v-else 指令实现条件渲染</li><li>能够使用 v-for 指令实现列表数据的循环渲染</li></ul><h2 id="vue-简介">1 vue 简介</h2><h3 id="什么是-vue">1. 什么是 vue</h3><p>官方给出的概念：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的前端框架。</p><h4 id="解读核心关键词构建用户界面">1.1 解读核心关键词：构建用户界面</h4><p>前端开发者最主要的工作，就是为网站的使用者（又称为：网站的用户）构建出美观、舒适、好用的网页。</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220704151223880.png" class=""><h4 id="构建用户界面的传统方式">1.2 构建用户界面的传统方式</h4><p>在传统的 Web 前端开发中，是基于 jQuery + 模板引擎 的方式来构建用户界面的。</p><ul><li><p>编写结构</p><p>基于模板引擎技术，把数据渲染到页面上。优点：初步解放了前端开发者，从此不用手动拼接字符串来渲染网页结构了。 缺点：1.需要定义大量的模板结构；2.缺少语法高亮和智能提示； 3.数据变化时需要重新调用模板编译的函数，否则页面结构不会更新；</p></li><li><p>美化样式</p><p>基础 CSS样式，美化网页的可视化效果。</p></li><li><p>处理交互</p><p>基于 jQuery 技术，处理用户和网页之间的交互行为。 优点：屏蔽了 DOM API 之间的兼容性，提高了 DOM 操作的效率和体验。 缺点：当业务复杂时、数据变化频繁时，前端程开发者需要把大量的时间和精力浪费在 DOM 的操作上，而不是核心业务的处理上。</p></li></ul><h4 id="使用-vue-构建用户界面">1.3 使用 vue 构建用户界面</h4><p>使用 vue 构建用户界面，解决了 jQuery + 模板引擎 的诸多痛点，极大的提高了前端开发的效率和体验。</p><ul><li><p>编写结构</p><p>基于 vue 中提供的指令，可以方便快捷的渲染页面的结构（乐不思蜀）。 数据驱动视图（只要页面依赖的数据源变化，则页面自动重新渲染） Ps：指令是 vue 为开发者提供的模板语法，用来辅助开发者渲染页面的结构。</p></li><li><p>美化样式</p><p>基础 CSS 样式，美化网页的可视化效果。</p></li><li><p>处理交互</p><p>基于 vue 中提供的事件绑定，可以轻松处理用户和页面之间的交互行为。 Ps：开发者把工作的重心放在核心业务的实现上</p></li></ul><h4 id="解读核心关键词框架">1.4 解读核心关键词：框架</h4><p>官方给 vue 的定位是前端框架，因为它提供了构建用户界面的一整套解决方案（俗称 vue 全家桶）：</p><ul><li>vue（核心库）</li><li>vue-router（路由方案）</li><li>vuex（状态管理方案）</li><li>vue 组件库（快速搭建页面 UI 效果的方案）</li></ul><p>以及辅助 vue 项目开发的一系列工具：</p><ul><li>vue-cli（npm 全局包：一键生成工程化的 vue 项目 - 基于 webpack、大而全）</li><li>vite（npm 全局包：一键生成工程化的 vue 项目 - 小而巧）</li><li>vue-devtools（浏览器插件：辅助调试的工具）</li><li>vetur（vscode 插件：提供语法高亮和智能提示）</li></ul><h4 id="总结什么是-vue">1.5 总结：什么是 vue</h4><p>vue 是一套用于构建用户界面的前端框架。</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220704151642355.png" class=""><h3 id="vue-的特性">2. vue 的特性</h3><p>vue 框架的特性，主要体现在如下两方面：</p><p>① 数据驱动视图</p><p>② 双向数据绑定</p><h4 id="数据驱动视图">2.1 数据驱动视图</h4><p>在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。示意图如下：</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220704152342633.png" class=""><ul><li>好处：当页面数据发生变化时，页面会自动重新渲染！</li><li>注意：数据驱动视图是单向的数据绑定。</li></ul><h4 id="双向数据绑定">2.2 双向数据绑定</h4><p>在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源 中。示意图如下：</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220704152421117.png" class=""><p>好处：开发者不再需要手动操作 DOM 元素，来获取表单元素最新的值！</p><h4 id="mvvm">2.3 MVVM</h4><p>MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。它把每个 HTML 页面都拆分成了如下三个部分：</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220704152506991.png" class=""><p>在 MVVM 概念中：</p><ul><li>View 表示当前页面所渲染的 DOM 结构。</li><li>Model 表示当前页面渲染时所依赖的数据源。</li><li>ViewModel 表示 vue 的实例，它是 MVVM 的核心。</li></ul><h4 id="mvvm-的工作原理">2.4 MVVM 的工作原理</h4><p>ViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220704152619944.png" class=""><ul><li>当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构</li><li>当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中</li></ul><h3 id="vue-的版本">3 vue 的版本</h3><p>当前，vue 共有 3 个大版本，其中：</p><ul><li><p>2.x 版本的 vue 是目前企业级项目开发中的主流版本</p></li><li><p>3.x 版本的 vue 于 2020-09-19 发布，生态还不完善，尚未在企业级项目开发中普及和推广</p></li><li><p>1.x 版本的 vue 几乎被淘汰，不再建议学习与使用</p></li></ul><p>总结：</p><ul><li><p>3.x 版本的 vue 是未来企业级项目开发的趋势；</p></li><li><p>2.x 版本的 vue 在未来（1 ~ 2年内）会被逐渐淘汰；</p></li></ul><h4 id="vue3.x-和-vue2.x-版本的对比">3.1 vue3.x 和 vue2.x 版本的对比</h4><p>vue2.x 中绝大多数的 API 与特性，在 vue3.x 中同样支持。同时，vue3.x 中还新增了 3.x 所特有的功能、并 废弃了某些 2.x 中的旧功能：</p><p>新增的功能例如： 组合式 API、多根节点组件、更好的 TypeScript 支持等</p><p>废弃的旧功能如下： 过滤器、不再支持 <span class="math inline">\(on，\)</span>off 和 $once 实例方法等</p><p>详细的变更信息，请参考官方文档给出的迁移指南： https://v3.vuejs.org/guide/migration/introduction.html</p><h2 id="vue-的基本使用">2 vue 的基本使用</h2><h3 id="基本使用步骤">1 基本使用步骤</h3><p>① 导入 vue.js 的 script 脚本文件</p><p>② 在页面中声明一个将要被 vue 所控制的 DOM 区域</p><p>③ 创建 vm 实例对象（vue 实例对象）</p><h2 id="vue的调试工具">3 vue的调试工具</h2><h2 id="vue的指令和过滤器">4 vue的指令和过滤器</h2><h4 id="指令的概念">1 指令的概念</h4><p>指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构</p><p>vue 中的指令按照不同的用途可以分为如下 6 大类：</p><p>① 内容渲染指令 ② 属性绑定指令 ③ 事件绑定指令 ④ 双向绑定指令 ⑤ 条件渲染指令 ⑥ 列表渲染指令</p><p>注意：指令是 vue 开发中最基础、最常用、最简单的知识点。</p><h4 id="内容渲染指令">1.1 内容渲染指令</h4><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个：</p><ul><li><p>v-text</p><p>注意：v-text 指令会覆盖元素内默认的值。</p></li><li><p><code>&#123;&#123;&#125;&#125;</code></p><p>解决v-text会覆盖元素默认值的问题，专业名称为插值表达式（Mustache）</p></li><li><p>v-html</p><p>上两条指令只能渲染纯文本内容，该指令可以渲染html内容</p></li></ul><h4 id="属性绑定指令">1.2 属性绑定指令</h4><p>如果需要为元素的属性动态绑定属性值，则需要用到 v-bind 属性绑定指令。用法示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind:placeholder</span>=<span class="hljs-string">&quot;inputValue&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;inputValue&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>渲染内部可以使用简单的表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27;+id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="事件绑定指令">1.3 事件绑定指令</h4><p>vue 提供了 v-on 事件绑定指令，用来辅助程序员为 DOM 元素绑定事件监听</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;addCount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addCount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后， 分别为：v-on:click、v-on:input、v-on:keyup</p><p>通过 v-on 绑定的事件处理函数，需要在 methods 节点中进行声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  <span class="hljs-attr">data</span>: &#123;count=<span class="hljs-number">0</span>&#125;,<br>  <span class="hljs-attr">method</span>: &#123;<br>    <span class="hljs-title function_">addCount</span>(<span class="hljs-params">e</span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=<span class="hljs-number">1</span><br>      e.<span class="hljs-property">target</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="事件对象-event">事件对象 event</h5><p>在原生的 DOM 事件绑定中，可以在事件处理函数的形参处，接收事件对象 event。同理，在 v-on 指令（简写为 @ ）所绑定的事件处理函数中，同样可以接收到事件对象 event，示例代码如下：</p><h5 id="绑定事件并传参">绑定事件并传参</h5><p><code>@click="addCount(1)"</code></p><h5 id="event">$event</h5><p><span class="math inline">\(event 是 vue 提供的特殊变量，用来表示原生的事件参数对象 event。\)</span>event 可以解决事件参数对象 event 被覆盖的问题。示例用法如下:</p><p><code>@click="addCount(1,$event)"</code></p><h5 id="事件修饰符">事件修饰符</h5><p>在事件处理函数中调用 preventDefault() 或 stopPropagation() 是非常常见的需求。因此，vue 提供了事件 修饰符的概念，来辅助程序员更方便的对事件的触发进行控制。常用的 5 个事件修饰符如下：</p><table><thead><tr class="header"><th>事件修饰符</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>.prevent</td><td>阻止默认行为（例如：阻止 a 连接的跳转、阻止表单的提交等）</td></tr><tr class="even"><td>.stop</td><td>阻止事件冒泡</td></tr><tr class="odd"><td>.capture</td><td>以捕获模式触发当前的事件处理函数</td></tr><tr class="even"><td>.once</td><td>绑定的事件只触发1次</td></tr><tr class="odd"><td>.self</td><td>只有在 event.target 是当前元素自身时触发事件处理函数</td></tr></tbody></table><p><code>@click.prevent</code></p><h5 id="按键修饰符">按键修饰符</h5><p>在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符，例如：</p><p><code>@keyup.enter="submit"</code></p><h4 id="双向绑定指令">1.4 双向绑定指令</h4><p>vue 提供了 v-model 双向数据绑定指令，用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据。</p><p><code>&lt;input type="text" v-model:"data"</code></p><p>注意：v-model 指令只能配合表单元素一起使用！</p><h5 id="v-model-指令的修饰符">v-model 指令的修饰符</h5><p>为了方便对用户输入的内容进行处理，vue 为 v-model 指令提供了 3 个修饰符，分别是：</p><table><thead><tr class="header"><th>修饰符</th><th>作用示例</th></tr></thead><tbody><tr class="odd"><td>.number</td><td>自动将用户的输入值转为数值类型&lt;input v-model.number="age" /&gt;</td></tr><tr class="even"><td>.trim</td><td>自动过滤用户输入的首尾空白字符&lt;input v-model.trim="msg" /&gt;</td></tr><tr class="odd"><td>.lazy</td><td>在“change”时而非“input”时更新&lt;input v-model.lazy="msg" /&gt;</td></tr></tbody></table><h4 id="条件渲染指令">1.5 条件渲染指令</h4><p>条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是：</p><ul><li><p>v-if</p><p>动态更新DOM元素</p></li><li><p>v-show</p><p>添加或移除<code>style="display:none"</code></p></li><li><p>v-else</p><p>v-if 可以单独使用，或配合 v-else 指令一起使用：</p></li><li><p>v-else-if</p><p>v-else-if 指令，顾名思义，充当 v-if 的“else-if 块”，可以连续使用</p></li></ul><h4 id="列表渲染指令">1.6 列表渲染指令</h4><p>vue 提供了 v-for 指令，用来辅助开发者基于一个数组来循环渲染相似的 UI 结构。</p><p>v-for 指令需要使用 item in items 的特殊语法，</p><p>其中： ⚫ items 是待循环的数组 ⚫ item 是当前的循环项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in items&quot;</span>&gt;</span>索引是: &#123;&#123;item.index&#125;&#125;, 姓名是: &#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="使用-key-维护列表的状态">使用 key 维护列表的状态</h5><p>当列表的数据变化时，默认情况下，vue 会尽可能的复用已存在的 DOM 元素，从而提升渲染的性能。</p><p>但这种 默认的性能优化策略，会导致有状态的列表无法被正确更新。</p><p>为了给 vue 一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲 染的性能。此时，需要为每项提供一个唯一的 key 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) in items&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;索引是: &#123;&#123;item.<span class="hljs-property">index</span>&#125;&#125;, 姓名是: &#123;&#123;item.<span class="hljs-property">name</span>&#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure><ul><li>key 的值只能是字符串或数字类型</li><li>key 的值必须具有唯一性（即：key 的值不能重复）</li><li>建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）</li><li>使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）</li><li>建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）</li></ul><h4 id="过滤器">2. 过滤器</h4><p>过滤器（Filters）常用于文本的格式化。例如：</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220707161835718.png" class=""><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220707161847138.png" class=""><p>2.2 私有过滤器和全局过滤器</p><p>在 filters 节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。 如果希望在多个 vue 实例之间共享过滤器，则可以按照如下的格式定义全局过滤器：</p><img src="/2022/07/04/%E5%89%8D%E7%AB%AF/Vue3/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20220707161904872.png" class=""><p>2.4 过滤器传参</p><p>过滤器的本质是 JavaScript 函数，因此可以接收参数，格式如下</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue3</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6模块化与异步编程高级用法</title>
    <link href="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/"/>
    <url>/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/</url>
    
    <content type="html"><![CDATA[<h2 id="目标">0 目标</h2><ul><li>能够知道如何使用 ES6 的模块化语法</li><li>能够知道如何使用 Promise 解决回调地狱的问题</li><li>能够知道如何使用 async/await 简化 Promise 的调用</li><li>能够说出什么是 EventLoop</li><li>能够说出宏任务和微任务的执行顺序</li></ul><h2 id="es6-模块化">1. ES6 模块化</h2><h3 id="回顾node.js-中如何实现模块化">1. 回顾：node.js 中如何实现模块化</h3><p>node.js 遵循了 CommonJS 的模块化规范。</p><p>其中：</p><p>⚫ 导入其它模块使用 require() 方法</p><p>⚫ 模块对外共享成员使用 module.exports 对象</p><p>模块化的好处：</p><p>大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</p><h3 id="前端模块化规范的分类">2. 前端模块化规范的分类</h3><p>在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范。</p><p>但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化 标准，例如：</p><p>⚫ AMD 和 CMD 适用于浏览器端的 Javascript 模块化</p><p>⚫ CommonJS 适用于服务器端的 Javascript 模块化</p><p>太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，大一统的 ES6 模块化规范诞生了！</p><h3 id="什么是-es6-模块化规范">3. 什么是 ES6 模块化规范</h3><p>ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。</p><p>ES6 模块化规范中定义：</p><ul><li>每个 js 文件都是一个独立的模块</li><li>导入其它模块成员使用 import 关键字</li><li>向外共享模块成员使用 export 关键字</li></ul><h3 id="在-node.js-中体验-es6-模块化">4. 在 node.js 中体验 ES6 模块化</h3><p>node.js 中默认仅支持 CommonJS 模块化规范，若想基于 node.js 体验与学习 ES6 的模块化语法，可以按照 如下两个步骤进行配置：</p><p>① 确保安装了 v14.15.1 或更高版本的 node.js</p><p>② 在 package.json 的根节点中添加 "type": "module" 节点</p><h3 id="es6-模块化的基本语法">5. ES6 模块化的基本语法</h3><p>ES6 的模块化主要包含如下 3 种用法：</p><ul><li>默认导出与默认导入</li><li>按需导出与按需导入</li><li>直接导入并执行模块中的代码</li></ul><h4 id="默认导出">5.1 默认导出</h4><p>默认导出的语法： export default 默认导出的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<span class="hljs-comment">//向外共享n1,show</span><br>  n1,<br>  show<br>&#125;<br></code></pre></td></tr></table></figure><p>默认导入的语法： import 接收名称 from '模块标识符'</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;.package.js&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="按需导出">5.2 按需导出</h4><p>按需导出的语法： export 按需导出的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&#x27;ccc&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按需导入的语法：<code>import &#123; s1 &#125; from '模块标识符'</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> info, &#123; s1, s2 <span class="hljs-keyword">as</span> str2, say &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./03.按需导出.js&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(say)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info)<br></code></pre></td></tr></table></figure><p>按需导出与按需导入的注意事项</p><p>① 每个模块中可以使用多次按需导出</p><p>② 按需导入的成员名称必须和按需导出的名称保持一致</p><p>③ 按需导入时，可以使用 as 关键字进行重命名</p><p>④ 按需导入可以和默认导入一起使用</p><h4 id="直接导入并执行模块中的代码">5.3 直接导入并执行模块中的代码</h4><p>如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模 块代码，示例代码如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701141917925.png" class=""><h2 id="promise">2 Promise</h2><h3 id="回调地狱">1. 回调地狱</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701143949601.png" class=""><p>回调地狱的缺点：</p><ul><li>代码耦合性太强，牵一发而动全身，难以维护</li><li>大量冗余的代码相互嵌套，代码的可读性变差</li></ul><h5 id="如何解决回调地狱的问题">1.1 如何解决回调地狱的问题</h5><p>为了解决回调地狱的问题，ES6（ECMAScript 2015）中新增了 Promise 的概念。</p><h5 id="promise-的基本概念">1.2 Promise 的基本概念</h5><p>① Promise 是一个构造函数</p><p>⚫ 我们可以创建 Promise 的实例 const p = new Promise()</p><p>⚫ new 出来的 Promise 实例对象，代表一个异步操作</p><p>② Promise.prototype 上包含一个 .then() 方法</p><p>⚫每一次 new Promise() 构造函数得到的实例对象，</p><p>⚫ 都可以通过原型链的方式访问到 .then() 方法，例如 p.then()</p><p>③ .then() 方法用来预先指定成功和失败的回调函数</p><p>⚫ p.then(成功的回调函数，失败的回调函数)</p><p>⚫ p.then(result =&gt; { }, error =&gt; { })</p><p>⚫ 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的</p><h3 id="基于回调函数按顺序读取文件内容">2. 基于回调函数按顺序读取文件内容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>  <br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="基于-then-fs-读取文件内容">3. 基于 then-fs 读取文件内容</h3><p>由于 node.js 官方提供的 fs 模块仅支持以回调函数的方式读取文件，不支持 Promise 的调用方式。因此，需要先运行如下的命令，安装 then-fs 这个第三方包，从而支持我们基于 Promise 的方式读取文件的内容：</p><h4 id="then-fs-的基本使用">3.1 then-fs 的基本使用</h4><p>调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因 此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)&#125;)<br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)&#125;)<br>thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)&#125;)<br></code></pre></td></tr></table></figure><p>注意：上述的代码无法保证文件的读取顺序，需要做进一步的改进！</p><h4 id="then-方法的特性">3.2 .then() 方法的特性</h4><p>如果上一个 .then() 方法中返回了一个新的 Promise 实例对象，则可以通过下一个 .then() 继续进行处理。通 过 .then() 方法的链式调用，就解决了回调地狱的问题。</p><h4 id="基于-promise-按顺序读取文件的内容">3.3 基于 Promise 按顺序读取文件的内容</h4><p>Promise 支持链式调用，从而来解决回调地狱的问题。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br>thenFs<br>  .<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r2)<br>    <span class="hljs-keyword">return</span> thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3)<br>  &#125;)<br></code></pre></td></tr></table></figure><h4 id="通过-.catch-捕获错误">3.4 通过 .catch 捕获错误</h4><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701154123814.png" class=""><p>如果不希望前面的错误导致后续的 .then 无法正常执行，则可以将 .catch 的调用提前，示例代码如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701154158285.png" class=""><h4 id="promise.all-方法">3.5 Promise.all() 方法</h4><p>Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then 操作（等待机制）。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br><span class="hljs-keyword">const</span> promiseArr = [<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>]<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promiseArr)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[r1, r2, r3]</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r1, r2, r3)<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意：数组中 Promise 实例的顺序， 就是最终结果的顺序！</p><h4 id="promise.race-方法">3.6 Promise.race() 方法</h4><p>Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的 .then 操作（赛跑机制）。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> thenFs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;then-fs&#x27;</span><br><br><span class="hljs-keyword">const</span> promiseArr = [<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/2.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>  thenFs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/1.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>),<br>]<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(promiseArr).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="基于-promise-封装读文件的方法">4. 基于 Promise 封装读文件的方法</h3><p>方法的封装要求：</p><p>① 方法的名称要定义为 getFile</p><p>② 方法接收一个形参 fpath，表示要读取的文件的路径</p><p>③ 方法的返回值为 Promise 实例对象</p><h5 id="getfile-方法的基本定义">4.1 getFile 方法的基本定义</h5><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701154957056.png" class=""><p>注意：第 5 行代码中的 new Promise() 只是创建了一个形式上的异步操作。</p><h5 id="创建具体的异步操作">4.2 创建具体的异步操作</h5><p>如果想要创建具体的异步操作，则需要在 new Promise() 构造函数期间，传递一个 function 函数，将具体的 异步操作定义到 function 函数内部。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(fpath, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123;<br>      <br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="获取-.then-的两个实参">4.3 获取 .then 的两个实参</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(fpath, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123;<br>      <br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">getFile</span>(<span class="hljs-string">&#x27;./file1.txt&#x27;</span>).<span class="hljs-title function_">then</span>(&lt;成功的回调函数&gt;, &lt;失败的回调函数&gt;)<br></code></pre></td></tr></table></figure><h5 id="调用-resolve-和-reject-回调函数">4.4 调用 resolve 和 reject 回调函数</h5><p>Promise 异步操作的结果，可以调用 resolve 或 reject 回调函数进行处理。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFile</span>(<span class="hljs-params">fpath</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(fpath, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(err)<br>      <span class="hljs-title function_">resolve</span>(dataStr)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">getFile</span>(<span class="hljs-string">&#x27;./file1.txt&#x27;</span>).<span class="hljs-title function_">then</span>(&lt;成功的回调函数&gt;, &lt;失败的回调函数&gt;)<br></code></pre></td></tr></table></figure><h2 id="asyncawait">3 async/await</h2><h3 id="什么是-asyncawait">1. 什么是 async/await</h3><p>async/await 是 ES8（ECMAScript 2017）引入的新语法，用来简化 Promise 异步操作。在 async/await 出 现之前，开发者只能通过链式 .then() 的方式处理 Promise 异步操作。示例代码如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701160440785.png" class=""><p>.then 链式调用的优点： 解决了回调地狱的问题</p><p>.then 链式调用的缺点： 代码冗余、阅读性差、 不易理解</p><h3 id="asyncawait-的基本使用">2. async/await 的基本使用</h3><p>使用 async/await 简化 Promise 异步操作的示例代码如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701160528040.png" class=""><h3 id="asyncawait-的使用注意事项">3. async/await 的使用注意事项</h3><p>① 如果在 function 中使用了 await，则 function 必须被 async 修饰</p><p>② 在 async 方法中，第一个 await 之前的代码会同步执行，await 之后的代码会异步执行</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701161020770.png" class=""><h2 id="eventloop">4 EventLoop</h2><h4 id="javascript-是单线程的语言">1. JavaScript 是单线程的语言</h4><p>JavaScript 是一门单线程执行的编程语言。也就是说，同一时间只能做一件事情。</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701161706016.png" class=""><p>单线程执行任务队列的问题： 如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致程序假死的问题。</p><h4 id="同步任务和异步任务">2. 同步任务和异步任务</h4><p>为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类：</p><p>① 同步任务（synchronous）</p><ul><li>又叫做非耗时任务，指的是在主线程上排队执行的那些任务</li><li>只有前一个任务执行完毕，才能执行后一个任务</li></ul><p>② 异步任务（asynchronous）</p><ul><li>又叫做耗时任务，异步任务由 JavaScript 委托给宿主环境进行执行</li><li>当异步任务执行完成后，会通知 JavaScript 主线程执行异步任务的回调函数</li></ul><h4 id="同步任务和异步任务的执行过程">3. 同步任务和异步任务的执行过程</h4><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701161835006.png" class=""><p>① 同步任务由 JavaScript 主线程次序执行</p><p>② 异步任务委托给宿主环境执行</p><p>③ 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行</p><p>④ JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，次序执行</p><p>⑤ JavaScript 主线程不断重复上面的第 4 步</p><h4 id="eventloop-的基本概念">4. EventLoop 的基本概念</h4><p>JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这 个过程是循环不断的，所以整个的这种运行机 制又称为 EventLoop（事件循环）。</p><h2 id="宏任务和微任务">5 宏任务和微任务</h2><h3 id="什么是宏任务和微任务">1. 什么是宏任务和微任务</h3><p>JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是：</p><p>① 宏任务（macrotask）</p><p>⚫ 异步 Ajax 请求、</p><p>⚫ setTimeout、setInterval、</p><p>⚫ 文件操作</p><p>⚫ 其它宏任务</p><p>② 微任务（microtask）</p><p>⚫ Promise.then、.catch 和 .finally</p><p>⚫ process.nextTick</p><p>⚫ 其它微任务</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701163716023.png" class=""><h3 id="宏任务和微任务的执行顺序">2. 宏任务和微任务的执行顺序</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701163809038.png" class=""><p>每一个宏任务执行完之后，都会检查是否存在待执行的微任务， 如果有，则执行完所有微任务之后，再继续执行下一个宏任务。</p><h3 id="去银行办业务的场景">3. 去银行办业务的场景</h3><p>① 小云和小腾去银行办业务。</p><p>首先，需要取号之后进行排队</p><p>⚫ 宏任务队列</p><p>② 假设当前银行网点只有一个柜员，小云在办理存款业务时，小腾只能等待</p><p>⚫ 单线程，宏任务按次序执行</p><p>③ 小云办完存款业务后，柜员询问他是否还想办理其它业务？</p><p>⚫ 当前宏任务执行完，检查是否有微任务</p><p>④ 小云告诉柜员：想要买理财产品、再办个信用卡、最后再兑换点马年纪念币？</p><p>⚫ 执行微任务，后续宏任务被推迟</p><p>⑤ 小云离开柜台后，柜员开始为小腾办理业务</p><p>⚫ 所有微任务执行完毕，开始执行下一个宏任务</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.js/image-20220701164147040.png" class=""><h2 id="api-接口案例">6 API 接口案例</h2><h3 id="案例需求">1. 案例需求</h3><p>基于 MySQL 数据库 + Express 对外提供用户列表的 API 接口服务。</p><p>用到的技术点如下：</p><p>⚫ 第三方包 express 和 mysql2</p><p>⚫ ES6 模块化</p><p>⚫ Promise</p><p>⚫ async/await</p><h2 id="总结">7 总结</h2><p>① 能够知道如何使用 ES6 的模块化语法</p><p>默认导出与默认导入、按需导出与按需导入</p><p>② 能够知道如何使用 Promise 解决回调地狱问题</p><p>promise.then()、promise.catch()</p><p>③ 能够使用 async/await 简化 Promise 的调用</p><p>方法中用到了 await，则方法需要被 async 修饰</p><p>④ 能够说出什么是 EventLoop</p><p>EventLoop 示意图</p><p>⑤ 能够说出宏任务和微任务的执行顺序</p><p>在执行下一个宏任务之前，先检查是否有待执行的微任务</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue3</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化与webpack</title>
    <link href="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/"/>
    <url>/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/</url>
    
    <content type="html"><![CDATA[<h2 id="目标">0 目标</h2><ul><li>能够说出什么是前端工程化</li><li>能够说出 webpack 的作用</li><li>能够掌握 webpack 的基本使用</li><li>了解常用 plugin 的基本使用</li><li>了解常用 loader 的基本使用</li><li>能够说出 Source Map 的作用</li></ul><h2 id="前端工程化">1 前端工程化</h2><h3 id="小白眼中的前端开发-vs-实际的前端开发">1. 小白眼中的前端开发 vs 实际的前端开发</h3><p>小白眼中的前端开发：</p><ul><li>会写 HTML + CSS + JavaScript 就会前端开发</li><li>需要美化页面样式，就拽一个 bootstrap 过来</li><li>需要操作 DOM 或发起 Ajax 请求，再拽一个 jQuery 过来</li><li>需要渲染模板结构，就用 art-template 等模板引擎</li></ul><p>实际的前端开发：</p><ul><li>模块化（js 的模块化、css 的模块化、其它资源的模块化）</li><li>组件化（复用现有的 UI 结构、样式、行为）</li><li>规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、 Git 分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><h3 id="什么是前端工程化">2. 什么是前端工程化</h3><p>前端工程化指的是：在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、 标准化。最终落实到细节上，就是实现前端的“4 个现代化”： 模块化、组件化、规范化、自动化</p><h3 id="前端工程化的好处">3. 前端工程化的好处</h3><p>前端工程化的好处主要体现在如下两方面：</p><ul><li>前端工程化让前端开发能够“自成体系”，覆盖了前端项目从创建到部署的方方面面</li><li>最大程度地提高了前端的开发效率，降低了技术选型、前后端联调等带来的协调沟通成本</li></ul><h3 id="前端工程化的解决方案">4. 前端工程化的解决方案</h3><p>早期的前端工程化解决方案：</p><ul><li>grunt（ https://www.gruntjs.net/ ）</li><li>gulp（ https://www.gulpjs.com.cn/ ）</li></ul><p>目前主流的前端工程化解决方案：</p><ul><li>webpack（ https://www.webpackjs.com/ ）</li><li>parcel（ https://zh.parceljs.org/ ）</li></ul><h2 id="webpack-的基本使用">2 webpack 的基本使用</h2><h3 id="什么是-webpack">1. 什么是 webpack</h3><p>概念：webpack 是前端项目工程化的具体解决方案。</p><p>主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性能优化等强大的功能。</p><p>好处：让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。 注意：目前企业级的前端项目开发中，绝大多数的项目都是基于 webpack 进行打包构建的。</p><h3 id="创建列表隔行变色项目">2. 创建列表隔行变色项目</h3><ul><li>① 新建项目空白目录，并运行 npm init –y 命令，初始化包管理配置文件 package.json</li><li>② 新建 src 源代码目录</li><li>③ 新建 src -&gt; index.html 首页和 src -&gt; index.js 脚本文件</li><li>④ 初始化首页基本的结构</li><li>⑤ 运行 npm install jquery –S 命令，安装 jQuery</li><li>⑥ 通过 ES6 模块化的方式导入 jQuery，实现列表隔行变色效果</li></ul><h3 id="在项目中安装-webpack">3. 在项目中安装 webpack</h3><p>在终端运行如下的命令，安装 webpack 相关的两个包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack@5.5.1 webpack-cli@4.2.0<br></code></pre></td></tr></table></figure><h3 id="在项目中配置-webpack">4. 在项目中配置 webpack</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220701171549911.png" class=""><h4 id="mode-的可选值">4.1 mode 的可选值</h4><p>mode 节点的可选值有两个，分别是：</p><p>① development</p><ul><li>开发环境</li><li>不会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度快，适合在开发阶段使用</li></ul><p>② production</p><ul><li>生产环境</li><li>会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度很慢，仅适合在项目发布阶段使用</li></ul><h4 id="webpack.config.js-文件的作用">4.2 webpack.config.js 文件的作用</h4><p>webpack.config.js 是 webpack 的配置文件。</p><p>webpack 在真正开始打包构建之前，会先读取这个配置文件， 从而基于给定的配置，对项目进行打包。</p><p>注意：由于 webpack 是基于 node.js 开发出来的打包工具，因此在它的配置文件中，支持使用 node.js 相关 的语法和模块进行 webpack 的个性化配置。</p><h4 id="webpack-中的默认约定">4.3 webpack 中的默认约定</h4><p>在 webpack 中有如下的默认约定：</p><ul><li>① 默认的打包入口文件为 src -&gt; index.js</li><li>② 默认的输出文件路径为 dist -&gt; main.js</li></ul><p>注意：可以在 webpack.config.js 中修改打包的默认约定</p><h4 id="自定义打包的入口与出口">4.4 自定义打包的入口与出口</h4><p>在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口。 示例代码如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220701172426011.png" class=""><h2 id="webpack-中的插件">3 webpack 中的插件</h2><h3 id="webpack-插件的作用">1. webpack 插件的作用</h3><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的 webpack 插件有如下两个：</p><p>① webpack-dev-server</p><ul><li>类似于 node.js 阶段用到的 nodemon 工具</li><li>每当修改了源代码，webpack 会自动进行项目的打包和构建</li></ul><p>② html-webpack-plugin</p><ul><li>webpack 中的 HTML 插件（类似于一个模板引擎插件）</li><li>可以通过此插件自定制 index.html 页面的内容</li></ul><h3 id="webpack-dev-server">2. webpack-dev-server</h3><p>webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。</p><h4 id="安装-webpack-dev-server">2.1 安装 webpack-dev-server</h4><p>运行如下的命令，即可在项目中安装此插件：</p><p><code>npm install webpack-dev-server@3.11.0</code></p><h4 id="配置-webpack-dev-server">2.2 配置 webpack-dev-server</h4><p>① 修改 package.json -&gt; scripts 中的 dev 命令如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220701212540996.png" class=""><p>② 再次运行 npm run dev 命令，重新进行项目的打包</p><p>③ 在浏览器中访问 http://localhost:8080 地址，查看自动打包效果</p><p>注意：webpack-dev-server 会启动一个实时打包的 http 服务器</p><h4 id="打包生成的文件哪儿去了">2.3 打包生成的文件哪儿去了？</h4><p>① 不配置 webpack-dev-server 的情况下，webpack 打包生成的文件，会存放到实际的物理磁盘上</p><ul><li>严格遵守开发者在 webpack.config.js 中指定配置</li><li>根据 output 节点指定路径进行存放</li></ul><p>② 配置了 webpack-dev-server 之后，打包生成的文件存放到了内存中</p><ul><li>不再根据 output 节点指定的路径，存放到实际的物理磁盘上</li><li>提高了实时打包输出的性能，因为内存比物理磁盘速度快很多</li></ul><h4 id="生成到内存中的文件该如何访问">2.4 生成到内存中的文件该如何访问？</h4><p>webpack-dev-server 生成到内存中的文件，默认放到了项目的根目录中，而且是虚拟的、不可见的。</p><ul><li>可以直接用 / 表示项目根目录，后面跟上要访问的文件名称，即可访问内存中的文件</li><li>例如 /bundle.js 就表示要访问 webpack-dev-server 生成到内存中的 bundle.js 文件</li></ul><h3 id="html-webpack-plugin">3. html-webpack-plugin</h3><p>html-webpack-plugin 是 webpack 中的 HTML 插件，可以通过此插件自定制 index.html 页面的内容。</p><p>需求：通过 html-webpack-plugin 插件，将 src 目录下的 index.html 首页，复制到项目根目录中一份！</p><h4 id="安装-html-webpack-plugin">3.1 安装 html-webpack-plugin</h4><p><code>npm install html-webpack-plugin</code></p><h4 id="配置-html-webpack-plugin">3.2 配置 html-webpack-plugin</h4><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220702165404615.png" class=""><h4 id="解惑-html-webpack-plugin">3.3 解惑 html-webpack-plugin</h4><p>① 通过 HTML 插件复制到项目根目录中的 index.html 页面，也被放到了内存中</p><p>② HTML 插件在生成的 index.html 页面的底部，自动注入了打包的 bundle.js 文件</p><h3 id="devserver-节点">4. devServer 节点</h3><p>在 webpack.config.js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置， 示例代码如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220702165703683.png" class=""><p>注意：凡是修改了 webpack.config.js 配置文件，或修改了 package.json 配置文件，必须重启实时打包的服 务器，否则最新的配置文件无法生效！</p><h2 id="webpack-中的-loader">4 webpack 中的 loader</h2><h3 id="loader-概述">1. loader 概述</h3><p>在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块， webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！</p><p>loader 加载器的作用：协助 webpack 打包处理特定的文件模块。比如：</p><ul><li>css-loader 可以打包处理 .css 相关的文件</li><li>less-loader 可以打包处理 .less 相关的文件</li><li>babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法</li></ul><h3 id="loader-的调用过程">2. loader 的调用过程</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220702165815414.png" class=""><h3 id="打包处理-css-文件">3. 打包处理 css 文件</h3><p>① 运行 npm i style-loader@2.0.0 css-loader@5.0.1 -D 命令，安装处理 css 文件的 loader ② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]&#125;<br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure><p>其中，test 表示匹配的文件类型， use 表示对应要调用的 loader</p><p>注意：</p><ul><li>use 数组中指定的 loader 顺序是固定的</li><li>多个 loader 的调用顺序是：从后往前调用</li></ul><h3 id="打包处理-less-文件">4. 打包处理 less 文件</h3><p>① 运行 npm i less-loader@7.1.0 less@3.12.2 -D 命令</p><p>② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>] &#125;,<br></code></pre></td></tr></table></figure><p>其中 ? 之后的是 loader 的参数项：</p><ul><li>limit 用来指定图片的大小，单位是字节（byte）</li><li>只有 ≤ limit 大小的图片，才会被转为 base64 格式的图片</li></ul><h3 id="打包处理样式表中与-url-路径相关的文件">5. 打包处理样式表中与 url 路径相关的文件</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704144915309.png" class=""><h4 id="loader-的另一种配置方式">5.1 loader 的另一种配置方式</h4><p>带参数项的 loader 还可以通过对象的方式进行配置：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704144812156.png" class=""><h3 id="打包处理-js-文件中的高级语法">6. 打包处理 js 文件中的高级语法</h3><p>webpack 只能打包处理一部分高级的 JavaScript 语法。对于那些 webpack 无法处理的高级 js 语法，需要借助于 babel-loader 进行打包处理。例如 webpack 无法处理下面的 JavaScript 代码：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704144838497.png" class=""><h4 id="安装-babel-loader-相关的包">6.1 安装 babel-loader 相关的包</h4><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704144944038.png" class=""><h4 id="配置-babel-loader">6.2 配置 babel-loader</h4><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145003380.png" class=""><h2 id="打包发布">5 打包发布</h2><h3 id="为什么要打包发布">1. 为什么要打包发布</h3><p>项目开发完成之后，使用 webpack 对项目进行打包发布的主要原因有以下两点：</p><ul><li>① 开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件</li><li>② 开发环境下，打包生成的文件不会进行代码压缩和性能优化</li></ul><p>为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布。</p><h3 id="配置-webpack-的打包发布">2. 配置 webpack 的打包发布</h3><p>在 package.json 文件的 scripts 节点下，新增 build 命令如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode production&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>--model 是一个参数项，用来指定 webpack 的运行模式。production 代表生产环境，会对打包生成的文件 进行代码压缩和性能优化。</p><p>注意：通过 --model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项。</p><h3 id="把-javascript-文件统一生成到-js-目录中">3. 把 JavaScript 文件统一生成到 js 目录中</h3><p>在 webpack.config.js 配置文件的 output 节点中，进行如下的配置：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145306175.png" class=""><h3 id="把图片文件统一生成到-image-目录中">4. 把图片文件统一生成到 image 目录中</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145327250.png" class=""><h3 id="自动清理-dist-目录下的旧文件">5. 自动清理 dist 目录下的旧文件</h3><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145342551.png" class=""><h3 id="企业级项目的打包发布">6. 企业级项目的打包发布</h3><p>企业级的项目在进行打包发布时，远比刚才的方式要复杂的多，主要的发布流程如下：</p><ul><li>生成打包报告，根据报告分析具体的优化方案</li><li>Tree-Shaking</li><li>为第三方库启用 CDN 加载</li><li>配置组件的按需加载</li><li>开启路由懒加载</li><li>自定制首页内容</li></ul><p>在后面的 vue 项目课程中，会专门讲解如何进行企业级项目的打包发布。</p><h2 id="source-map">6 Source Map</h2><h3 id="生产环境遇到的问题">1. 生产环境遇到的问题</h3><p>前端项目在投入生产环境之前，都需要对 JavaScript 源代码进行压缩混淆，从而减小文件的体积，提高文件的 加载效率。此时就不可避免的产生了另一个问题：</p><p>对压缩混淆之后的代码除错（debug）是一件极其困难的事情</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145555099.png" class=""><ul><li>变量被替换成没有任何语义的名称</li><li>空行和注释被剔除</li></ul><h3 id="什么是-source-map">2. 什么是 Source Map</h3><p>Source Map 就是一个信息文件，里面储存着位置信息。也就是说，Source Map 文件中存储着代码压缩混淆 前后的对应关系。</p><p>有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试。</p><h3 id="webpack-开发环境下的-source-map">3. webpack 开发环境下的 Source Map</h3><p>在开发环境下，webpack 默认启用了 Source Map 功能。当程序运行出错时，可以直接在控制台提示错误行 的位置，并定位到具体的源代码：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145642792.png" class=""><h4 id="默认-source-map-的问题">3.1 默认 Source Map 的问题</h4><p>开发环境下默认生成的 Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行 数不一致的问题。示意图如下：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704145955525.png" class=""><h4 id="解决默认-source-map-的问题">3.2 解决默认 Source Map 的问题</h4><p>开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数 保持一致：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704150012634.png" class=""><h3 id="webpack-生产环境下的-source-map">4. webpack 生产环境下的 Source Map</h3><p>在生产环境下，如果省略了 devtool 选项，则最终生成的文件中不包含 Source Map。这能够防止原始代码通过 Source Map 的形式暴露给别有所图之人。</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704150112684.png" class=""><h4 id="只定位行数不暴露源码">4.1 只定位行数不暴露源码</h4><p>在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以将 devtool 的值设置为 nosources-source-map。实际效果如图所示：</p><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704150126051.png" class=""><h4 id="定位行数且暴露源码">4.2 定位行数且暴露源码</h4><img src="/2022/07/01/%E5%89%8D%E7%AB%AF/Vue3/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/image-20220704150158471.png" class=""><h3 id="source-map-的最佳实践">5. Source Map 的最佳实践</h3><p>① 开发环境下：</p><ul><li><p>建议把 devtool 的值设置为 eval-source-map</p></li><li><p>好处：可以精准定位到具体的错误行</p></li></ul><p>② 生产环境下：</p><ul><li>建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map</li><li>好处：防止源码泄露，提高网站的安全性</li></ul><h3 id="实际开发中需要自己配置-webpack-吗">6 实际开发中需要自己配置 webpack 吗？</h3><p>答案：不需要！</p><ul><li>实际开发中会使命令行工具（俗称 CLI）一键生成带有 webpack 的项目</li><li>开箱即用，所有 webpack 配置项都是现成的！</li><li>我们只需要知道 webpack 中的基本概念即可！</li></ul><h2 id="总结">7 总结</h2><p>① 能够掌握 webpack 的基本使用</p><p>安装、webpack.config.js、修改打包入口</p><p>② 了解常用的 plugin 的基本使用</p><p>webpack-dev-server、html-webpack-plugin</p><p>③ 了解常用的 loader 的基本使用</p><p>loader 的作用、loader的调用过程</p><p>④ 能够说出 Source Map 的作用</p><p>精准定位到错误行并显示对应的源码 方便开发者调试源码中的错误</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue3</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm命令行开发</title>
    <link href="/2022/06/30/%E6%9D%82%E9%A1%B9/npm%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%8F%91/"/>
    <url>/2022/06/30/%E6%9D%82%E9%A1%B9/npm%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="目的">0 目的</h2><p>项目开发需要辅助程序，为了减轻团队内部使用辅助程序时出现的分发和同步问题，使用npm包管理器进行分发同步，用node环境下的javascript进行程序的开发。</p><p>在这基础上，为了使辅助程序更易于使用，从原本需要导入javascript包，编写代码运行程序，进一步开发出命令行下的程序，实现目标如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fakedatagen [-i &lt;config-file-name&gt;] [-o &lt;result-file-name&gt;]<br></code></pre></td></tr></table></figure><ul><li><p><code>[-i]</code>：根据输入配置文件名进行结果输出，无该配置项时，从命令行当前目录搜索<code>config.json</code>配置文件，如果没有则报错</p></li><li><p><code>[-o]</code>：根据输出文件名进行结果输出，无该配置项时，直接输出<code>result.txt</code>文件名</p></li></ul><h2 id="npm-run命令">1 npm run命令</h2><p>在当前node开发目录下的<code>config.json</code>中，<code>run</code>可运行配置文件中的<code>scripts</code>脚本</p><h2 id="npx命令">2 npx命令</h2><p>运行导入模块中的脚本文件，npx会先搜索当前目录再搜索全局目录</p><h2 id="npm开发全局脚本">3 npm开发全局脚本</h2><h3 id="局部模块配合全局链接">3.1 局部模块配合全局链接</h3><p>在局部模块中使用<code>npm link</code>将当前模块中<code>bin</code>目录下脚本文件链接到全局命令中</p><h3 id="全局模块安装">3.2 全局模块安装</h3><p>使用<code>npm install &lt;package-name&gt; -g</code>全局安装</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>numjs安装报错</title>
    <link href="/2022/06/30/%E6%9D%82%E9%A1%B9/numjs%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"/>
    <url>/2022/06/30/%E6%9D%82%E9%A1%B9/numjs%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>numjs depends on sharp, and sharp depends on libvips</p><p><code>yarn add numjs</code> will be failed installing libvips because sharp ^0.27.2 downloads wrong binary</p><p>At the Sharp documentation, they said</p><p><em>Prebuilt sharp and libvips binaries have been provided for macOS on ARM64 since sharp v0.29.0.</em></p><p>so the package.json should be updated to use this library.</p><hr /><p>FYI</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>libvips<br>yarn <span class="hljs-keyword">add </span>numjs<br></code></pre></td></tr></table></figure><p>This works for quick fix :)</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql连接错误</title>
    <link href="/2022/06/29/%E6%9D%82%E9%A1%B9/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF/"/>
    <url>/2022/06/29/%E6%9D%82%E9%A1%B9/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>node首次连接mysql，报错Client does not support authentication protocol requested by server的问题</p></blockquote><p>原因： 在项目里面通过npm install 安装的mysql和最新版本MySQL加密方式不同，导致连接失败。</p><p>在最新下载的MySql客户端版本使用的是caching_sha2_password加密方式，所以默认创建的root用户和密码都是这个加密方式。而npm包里的mysql模块还是使用原来的mysql_native_password加密方式，两者不互通，连接会报错。</p><p>解决方法： 将mysql的用户密码从caching_sha2_password加密方式改回mysql模块能支持的 mysql_native_password加密方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u [user_name] -p [password]<br><br>ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>postgresql连接</title>
    <link href="/2022/06/29/%E6%9D%82%E9%A1%B9/postgresql%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/06/29/%E6%9D%82%E9%A1%B9/postgresql%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在 mac 下，可以利用 homebrew 直接安装 PostgreSQL：</span><br>$ brew install postgresql<br> <br><span class="hljs-comment">#稍等片刻，PostgreSQL 就安装完成。接下来就是初始数据库，在终端执行一下命令，初始配置 #PostgreSQL：</span><br> <br>$ initdb /usr/local/var/postgres -E utf8<br> <br><span class="hljs-comment">#上面指定 &quot;/usr/local/var/postgres&quot; 为 PostgreSQL 的配置数据存放目录，并且设置数据库数据编#码是 utf8，更多配置信息可以 &quot;initdb --help&quot; 查看。</span><br> <br><span class="hljs-comment">#设成开机启动 PostgreSQL：</span><br>$ <span class="hljs-built_in">ln</span> -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents<br>$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist<br> <br><span class="hljs-comment">#启动 PostgreSQL：</span><br><span class="hljs-comment">#启动方式一 </span><br>brew services start postgresql<br><span class="hljs-comment">#启动方式二</span><br> pg_ctl -D /usr/local/var/postgres start<br><span class="hljs-comment">#启动方式三</span><br>postgres -D /usr/local/var/postgres<br><span class="hljs-comment">#启动方式四（打印日志）</span><br>$ pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start<br><br><span class="hljs-comment">#关闭 PostgreSQL：</span><br>$ pg_ctl -D /usr/local/var/postgres stop -s -m fast<br> <br><span class="hljs-comment">#创建一个 PostgreSQL 用户</span><br>$ createuser username -P<br><span class="hljs-comment">#Enter password for new role:</span><br><span class="hljs-comment">#Enter it again:</span><br> <br><span class="hljs-comment">#上面的 username 是用户名，回车输入 2 次用户密码后即用户创建完成。更多用户创建信息可以 &quot;createuser --help&quot; 查看。</span><br> <br><span class="hljs-comment">#创建数据库</span><br>$ createdb dbname -O username -E UTF8 -e<br> <br><span class="hljs-comment">#上面创建了一个名为 dbname 的数据库，并指定 username 为改数据库的拥有者（owner），数据库的编码（encoding）是 UTF8，参数 &quot;-e&quot; 是指把数据库执行操作的命令显示出来。</span><br> <br><span class="hljs-comment">#更多数据库创建信息可以 &quot;createdb --help&quot; 查看。</span><br> <br><span class="hljs-comment">#连接数据库</span><br>$ psql -U username -d dbname -h 127.0.0.1<br> <br><span class="hljs-comment">#PostgreSQL 数据库操作</span><br> <br><span class="hljs-comment">#显示已创建的数据库：</span><br>$ \l<br> <br><span class="hljs-comment">#在不连接进 PostgreSQL 数据库的情况下，也可以在终端上查看显示已创建的列表：</span><br>$ psql -l<br> <br><span class="hljs-comment">#连接数据库</span><br>$ \c dbname<br> <br><span class="hljs-comment">#显示数据库表</span><br>$ \d  <br> <br><span class="hljs-comment">#创建表 和sql的建表语句一样</span><br>$ create table tablename (xxx ... ) <br> <br><span class="hljs-comment">#插入记录</span><br>$ INSERT INTO tablename ( ... )<br> <br><span class="hljs-comment">#查询数据</span><br>$ SELECT * FROM table [<span class="hljs-built_in">where</span> .... ] [<span class="hljs-built_in">join</span> ... ] ... <br> <br><span class="hljs-comment">#更新记录</span><br>$ UPDATE tablename SET fieldName = <span class="hljs-string">&#x27;value&#x27;</span> [WHERE ... ];<br> <br><span class="hljs-comment">#删除指定的记录</span><br>$ DELETE FROM tablename [WHERE <span class="hljs-built_in">id</span> = 1];<br> <br><span class="hljs-comment">#删除表</span><br>$ DROP TABLE tablename;<br> <br><span class="hljs-comment">#删除数据库</span><br>$ DROP DATABASE dbname;<br> <br><span class="hljs-comment">#或者利用 dropdb 指令，在终端上删除数据库</span><br>$ dropdb -U user dbname<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库与身份认证</title>
    <link href="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <url>/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库与身份认证">数据库与身份认证</h2><h3 id="目标">0 目标</h3><ul><li>能够知道如何配置 MySQL 数据库环境</li><li>能够认识并使用常见的 SQL 语句操作数据库</li><li>能够在项目中操作 MySQL 数据库</li><li>能够了解 Session 的实现原理</li><li>能够了解 JWT 的实现原理</li></ul><h3 id="数据库的基本概念">1. 数据库的基本概念</h3><h4 id="什么是数据库">1.1 什么是数据库</h4><p>数据库（database）是用来组织、存储和管理数据的仓库。 当今世界是一个充满着数据的互联网世界，充斥着大量的数据。数据的来源有很多，比如出行记录、消费记录、 浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。</p><p>为了方便管理互联网世界中的数据，就有了数据库管理系统的概念（简称：数据库）。用户可以对数据库中的数 据进行新增、查询、更新、删除等操作。</p><h4 id="常见的数据库及分类">1.2 常见的数据库及分类</h4><p>市面上的数据库有很多种，最常见的数据库有如下几个：</p><p>⚫ MySQL 数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）</p><p>⚫ Oracle 数据库（收费）</p><p>⚫ SQL Server 数据库（收费）</p><p>⚫ Mongodb 数据库（Community + Enterprise）</p><p>其中，MySQL、Oracle、SQL Server 属于传统型数据库（又叫做：关系型数据库 或 SQL 数据库），这三者的 设计理念相同，用法比较类似。 而 Mongodb 属于新型数据库（又叫做：非关系型数据库 或 NoSQL 数据库），它在一定程度上弥补了传统型 数据库的缺陷。</p><h4 id="传统型数据库的数据组织结构">1.3 传统型数据库的数据组织结构</h4><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220628171426886.png" class=""><h5 id="excel-的数据组织结构">1. Excel 的数据组织结构</h5><p>每个 Excel 中，数据的组织结构分别为工作簿、工作表、数据行、列这 4 大部分组成。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220628171712901.png" class=""><h5 id="传统型数据库的数据组织结构-1">2. 传统型数据库的数据组织结构</h5><p>在传统型数据库中，数据的组织结构分为数据库(database)、数据表(table)、数据行(row)、字段(field)这 4 大部分组成。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220628171744092.png" class=""><h5 id="实际开发中库表行字段的关系">3. 实际开发中库、表、行、字段的关系</h5><p>① 在实际项目开发中，一般情况下，每个项目都对应独立的数据库。</p><p>② 不同的数据，要存储到数据库的不同表中，例如：用户数据存储到 users 表中，图书数据存储到 books 表中。</p><p>③ 每个表中具体存储哪些信息，由字段来决定，例如：我们可以为 users 表设计 id、username、password 这 3 个 字段。</p><p>④ 表中的行，代表每一条具体的数据。</p><h3 id="安装并配置-mysql">2. 安装并配置 MySQL</h3><h4 id="了解需要安装哪些mysql相关的软件">2.1 了解需要安装哪些MySQL相关的软件</h4><p>对于开发人员来说，只需要安装 MySQL Server 和 MySQL Workbench 这两个软件，就能满足开发的需要了。</p><p>⚫ MySQL Server：专门用来提供数据存储和服务的软件。</p><p>⚫ MySQL Workbench：可视化的 MySQL 管理工具，通过它，可以方便的操作存储在 MySQL Server 中的数据。</p><h3 id="mysql-的基本使用">3. MySQL 的基本使用</h3><h4 id="使用-mysql-workbench-管理数据库">3.1 使用 MySQL Workbench 管理数据库</h4><h5 id="连接数据库">1. 连接数据库</h5><h5 id="了解主界面的组成部分">2. 了解主界面的组成部分</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220628172651145.png" class=""><h5 id="创建数据库">3. 创建数据库</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220628172841818.png" class=""><h5 id="创建数据表">4. 创建数据表</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629153629458.png" class=""><h5 id="向表中写入数据">5. 向表中写入数据</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629153701880.png" class=""><h4 id="使用-sql-管理数据库">3.2 使用 SQL 管理数据库</h4><h5 id="什么是-sql">1. 什么是 SQL</h5><p>SQL（英文全称：Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让 我们以编程的形式，操作数据库里面的数据。</p><p>三个关键点： ① SQL 是一门数据库编程语言 ② 使用 SQL 语言编写出来的代码，叫做 SQL 语句 ③ SQL 语言只能在关系型数据库中使用（例如 MySQL、Oracle、SQL Server）。非关系型数据库（例如 Mongodb） 不支持 SQL 语言</p><h5 id="sql-能做什么">2. SQL 能做什么</h5><ul><li>从数据库中查询数据</li><li>向数据库中插入新的数据</li><li>更新数据库中的数据</li><li>从数据库删除数据</li><li>可以创建新数据库</li><li>可在数据库中创建新表</li><li>可在数据库中创建存储过程、视图</li><li>etc…</li></ul><h5 id="sql-的学习目标">3. SQL 的学习目标</h5><p>重点掌握如何使用 SQL 从数据表中： 查询数据（select） 、插入数据（insert into） 、更新数据（update） 、删除数据（delete）</p><p>额外需要掌握的 4 种 SQL 语法： where 条件、and 和 or 运算符、order by 排序、count(*) 函数</p><h4 id="sql-的-select-语句">3.3 SQL 的 SELECT 语句</h4><h5 id="语法">1 语法</h5><p>SELECT 语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集）。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from [table_name]<br>select col_name [,clo_name] from [table_name]<br></code></pre></td></tr></table></figure><p>注意：SQL 语句中的关键字对大小写不敏感。SELECT 等效于 select，FROM 等效于 from。</p><h4 id="sql-的-insert-into-语句">3.4 SQL 的 INSERT INTO 语句</h4><h5 id="语法-1">1 语法</h5><p>INSERT INTO 语句用于向数据表中插入新的数据行，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [table_name] (col_1, col_2, ...) values (val_1, val_2, ...)<br></code></pre></td></tr></table></figure><h4 id="sql-的-update-语句">3.5 SQL 的 UPDATE 语句</h4><h5 id="语法-2">1. 语法</h5><p>Update 语句用于修改表中的数据。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update [table_name] set [col_1] = [new_val_1] where [col_1] = [old_val_1]<br></code></pre></td></tr></table></figure><h4 id="sql-的-delete-语句">3.6 SQL 的 DELETE 语句</h4><p>DELETE 语句用于删除表中的行。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from [table_name] where [col_1]=[val_1]<br></code></pre></td></tr></table></figure><h4 id="sql-的-where-子句">3.7 SQL 的 WHERE 子句</h4><h5 id="语法-3">1. 语法</h5><p>WHERE 子句用于限定选择的标准。在 SELECT、UPDATE、DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。</p><h5 id="可在-where-子句中使用的运算符">2 可在 WHERE 子句中使用的运算符</h5><p>下面的运算符可在 WHERE 子句中使用，用来限定选择的标准：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629155806535.png" class=""><p>注意：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=</p><h5 id="示例">3 示例</h5><p>可以通过 WHERE 子句来限定 SELECT 的查询条件：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629155850823.png" class=""><h4 id="sql-的-and-和-or-运算符">3.8 SQL 的 AND 和 OR 运算符</h4><h5 id="语法-4">1 语法</h5><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p><p>AND 表示必须同时满足多个条件，相当于 JavaScript 中的 &amp;&amp; 运算符，例如 if (a !== 10 &amp;&amp; a !== 20)</p><p>OR 表示只要满足任意一个条件即可，相当于 JavaScript 中的 || 运算符，例如 if(a !== 10 || a !== 20)</p><h5 id="and-运算符示例">2 AND 运算符示例</h5><p>使用 AND 来显示所有 status 为 0，并且 id 小于 3 的用户：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160007708.png" class=""><h5 id="or-运算符示例">2. OR 运算符示例</h5><p>使用 OR 来显示所有 status 为 1，或者 username 为 zs 的用户：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160024255.png" class=""><h4 id="sql-的-order-by-子句">3.9 SQL 的 ORDER BY 子句</h4><h5 id="语法-5">1. 语法</h5><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p><p>ORDER BY 语句默认按照升序对记录进行排序。</p><p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p><h5 id="order-by-子句---升序排序">2. ORDER BY 子句 - 升序排序</h5><p>对 users 表中的数据，按照 status 字段进行升序排序，示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160113901.png" class=""><h5 id="order-by-子句-降序排序">3. ORDER BY 子句 – 降序排序</h5><p>对 users 表中的数据，按照 id 字段进行降序排序，示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160222758.png" class=""><h5 id="order-by-子句-多重排序">4. ORDER BY 子句 – 多重排序</h5><p>对 users 表中的数据，先按照 status 字段进行降序排序，再按照 username 的字母顺序，进行升序排序，示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160239525.png" class=""><h4 id="sql-的-count-函数">3.10 SQL 的 COUNT(*) 函数</h4><h5 id="语法-6">1. 语法</h5><p>COUNT(*) 函数用于返回查询结果的总数据条数，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(*) from [table_name] [where ...]<br></code></pre></td></tr></table></figure><h5 id="使用-as-为列设置别名">2. 使用 AS 为列设置别名</h5><p>如果希望给查询出来的列名称设置别名，可以使用 AS 关键字，示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160416997.png" class=""><h3 id="在项目中操作-mysql">4. 在项目中操作 MySQL</h3><h4 id="在项目中操作数据库的步骤">4.1 在项目中操作数据库的步骤</h4><ul><li>安装操作 MySQL 数据库的第三方模块（mysql）</li><li>通过 mysql 模块连接到 MySQL 数据库</li><li>通过 mysql 模块执行 SQL 语句</li></ul><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629160557203.png" class=""><h4 id="安装与配置-mysql-模块">4.2 安装与配置 mysql 模块</h4><h5 id="安装-mysql-模块">1. 安装 mysql 模块</h5><p>mysql 模块是托管于 npm 上的第三方模块。它提供了在 Node.js 项目中连接和操作 MySQL 数据库的能力。 想要在项目中使用它，需要先运行如下命令，将 mysql 安装为项目的依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install mysql<br></code></pre></td></tr></table></figure><h5 id="配置-mysql-模块">2. 配置 mysql 模块</h5><p>在使用 mysql 模块操作 MySQL 数据库之前，必须先对 mysql 模块进行必要的配置，主要的配置步骤如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;my_db_01&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="使用-mysql-模块操作-mysql-数据库">4.3 使用 mysql 模块操作 MySQL 数据库</h4><h5 id="查询数据">1. 查询数据</h5><blockquote><p>新版mysql数据库密码加密和node中mysql密码加密方式不符，需要修改mysql数据库密码加密方式</p></blockquote><p>调用 db.query() 函数，指定要执行的 SQL 语句，通过回调函数拿到执行的结果：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220629163724300.png" class=""><h5 id="插入数据">2. 插入数据</h5><p>向 users 表中新增数据， 其中 username 为 Spider-Man，password 为 pcc321。示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630160306316.png" class=""><h5 id="插入数据的便捷方式">3. 插入数据的便捷方式</h5><h3 id="前后端的身份认证">5. 前后端的身份认证</h3><h4 id="web-开发模式">5.1 Web 开发模式</h4><p>目前主流的 Web 开发模式有两种，分别是：</p><p>① 基于服务端渲染的传统 Web 开发模式</p><p>② 基于前后端分离的新型 Web 开发模式</p><h5 id="服务端渲染的-web-开发模式">1 服务端渲染的 Web 开发模式</h5><p>服务端渲染的概念：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不 需要使用 Ajax 这样的技术额外请求页面的数据。代码示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630171113599.png" class=""><h5 id="服务端渲染的优缺点">2. 服务端渲染的优缺点</h5><p>优点：</p><p>① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 ② 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。</p><p>缺点：</p><p>① 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。</p><p>② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于 项目高效开发。</p><h5 id="前后端分离的-web-开发模式">3. 前后端分离的 Web 开发模式</h5><p>前后端分离的概念：前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。简而言之，前后端分离的 Web 开发模式， 就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式。</p><h5 id="前后端分离的优缺点">4. 前后端分离的优缺点</h5><p>优点：</p><p>① 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。</p><p>② 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。</p><p>③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。</p><p>缺点：</p><p>① 不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方 案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！）</p><h5 id="如何选择-web-开发模式">5. 如何选择 Web 开发模式</h5><p>不谈业务场景而盲目选择使用何种开发模式都是耍流氓。</p><p>比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染； 而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。</p><p>另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了 首屏服务器端渲染 + 其他页面前后端分离的开发模式。</p><h4 id="身份认证">5.2 身份认证</h4><h5 id="什么是身份认证">1. 什么是身份认证</h5><p>身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。</p><p>⚫ 日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。 ⚫ 在 Web 开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。</p><h5 id="为什么需要身份认证">2. 为什么需要身份认证</h5><p>身份认证的目的，是为了确认当前所声称为某种身份的用户，确实是所声称的用户。例如，你去找快递员取快递，你要怎 么证明这份快递是你的。</p><p>在互联网项目开发中，如何对用户的身份进行认证，是一个值得深入探讨的问题。例如，如何才能保证网站不会错误的将 “马云的存款数额”显示到“马化腾的账户”上。</p><h5 id="不同开发模式下的身份认证">3. 不同开发模式下的身份认证</h5><p>对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p><p>① 服务端渲染推荐使用 Session 认证机制</p><p>② 前后端分离推荐使用 JWT 认证机制</p><h4 id="session-认证机制">5.3 Session 认证机制</h4><h5 id="http-协议的无状态性">1. HTTP 协议的无状态性</h5><p>了解 HTTP 协议的无状态性是进一步学习 Session 认证机制的必要前提。</p><p>HTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会 主动保留每次 HTTP 请求的状态。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630214030387.png" class=""><h5 id="如何突破-http-无状态的限制">2. 如何突破 HTTP 无状态的限制</h5><p>对于超市来说，为了方便收银员在进行结算时给 VIP 用户打折，超市可以为每个 VIP 用户发放会员卡。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630214051319.png" class=""><p>注意：现实生活中的会员卡身份认证方式，在 Web 开发中的专业术语叫做 Cookie。</p><h5 id="什么是-cookie">3. 什么是 Cookie</h5><p>Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。</p><p>不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。</p><p>Cookie的几大特性：</p><p>① 自动发送 ② 域名独立 ③ 过期时限 ④ 4KB 限制</p><h5 id="cookie-在身份认证中的作用">4. Cookie 在身份认证中的作用</h5><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动</p><p>将 Cookie 保存在浏览器中。</p><p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给</p><p>服务器，服务器即可验明客户端的身份。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630214202106.png" class=""><h5 id="cookie-不具有安全性">5. Cookie 不具有安全性</h5><p>由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630214246347.png" class=""><p>注意：千万不要使用 Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等。</p><h5 id="提高身份认证的安全性">6. 提高身份认证的安全性</h5><p>为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证。只有收银机确认存在的 会员卡，才能被正常使用。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630214312690.png" class=""><p>这种“会员卡 + 刷卡认证”的设计理念，就是 Session 认证机制的精髓。</p><h5 id="session-的工作原理">7. Session 的工作原理</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630214338269.png" class=""><h4 id="在-express-中使用-session-认证">5.4 在 Express 中使用 Session 认证</h4><h5 id="安装-express-session-中间件">1. 安装 express-session 中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install express-session<br></code></pre></td></tr></table></figure><h5 id="配置-express-session-中间件">2. 配置 express-session 中间件</h5><p>express-session 中间件安装成功后，需要通过 app.use() 来注册 session 中间件，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;<br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;keyboard cat&#x27;</span>,<br>  <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">saveUninitalized</span>: <span class="hljs-literal">true</span><br>&#125;))<br></code></pre></td></tr></table></figure><h5 id="向-session-中存数据">3. 向 session 中存数据</h5><p>当 express-session 中间件配置成功后，即可通过 req.session 来访问和使用 session 对象，从而存储用户的关键信息：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231333219.png" class=""><h5 id="从-session-中取数据">4. 从 session 中取数据</h5><p>可以直接从 req.session 对象上获取之前存储的数据，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231536004.png" class=""><h5 id="清空-session">5. 清空 session</h5><p>调用 req.session.destroy() 函数，即可清空服务器保存的 session 信息。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231612130.png" class=""><h4 id="jwt-认证机制">5.5 JWT 认证机制</h4><h5 id="了解-session-认证的局限性">1. 了解 Session 认证的局限性</h5><p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</p><p>注意：</p><p>⚫ 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</p><p>⚫ 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。</p><h5 id="什么是-jwt">2. 什么是 JWT</h5><p>JWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。</p><h5 id="jwt-的工作原理">3. JWT 的工作原理</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231743889.png" class=""><p>总结：用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><h5 id="jwt-的组成部分">4. JWT 的组成部分</h5><p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。 三者之间使用英文的“.”分隔，格式如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231822217.png" class=""><p>下面是 JWT 字符串的示例：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231832794.png" class=""><h5 id="jwt-的三个部分各自代表的含义">6. JWT 的三个部分各自代表的含义</h5><p>JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。</p><p>其中：</p><p>⚫ Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。</p><p>⚫ Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231858093.png" class=""><h5 id="jwt-的使用方式">7. JWT 的使用方式</h5><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231914758.png" class=""><h4 id="在-express-中使用-jwt">5.6 在 Express 中使用 JWT</h4><h5 id="安装-jwt-相关的包">1. 安装 JWT 相关的包</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630231948216.png" class=""><p>其中：</p><ul><li>jsonwebtoken 用于生成 JWT 字符串</li><li>express-jwt 用于将 JWT 字符串解析还原成 JSON 对象</li></ul><h5 id="导入-jwt-相关的包">2. 导入 JWT 相关的包</h5><p>使用 require() 函数，分别导入 JWT 相关的两个包：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630232017329.png" class=""><h5 id="定义-secret-密钥">3. 定义 secret 密钥</h5><p>为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密 的 secret 密钥：</p><p>① 当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串</p><p>② 当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630232042366.png" class=""><h5 id="在登录成功后生成-jwt-字符串">4. 在登录成功后生成 JWT 字符串</h5><p>调用 jsonwebtoken 包提供的 sign() 方法，将用户的信息加密成 JWT 字符串，响应给客户端：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630232100369.png" class=""><h5 id="将-jwt-字符串还原为-json-对象">5. 将 JWT 字符串还原为 JSON 对象</h5><p>客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的 Authorization 字段，将 Token 字符串发 送到服务器进行身份认证。</p><p>此时，服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630232119446.png" class=""><h5 id="使用-req.user-获取用户信息">6. 使用 req.user 获取用户信息</h5><p>当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串 中解析出来的用户信息了，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630232135287.png" class=""><h5 id="捕获解析-jwt-失败后产生的错误">7. 捕获解析 JWT 失败后产生的错误</h5><p>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败 的错误，影响项目的正常运行。我们可以通过 Express 的错误中间件，捕获这个错误并进行相关的处理，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/image-20220630232152091.png" class="">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>brew安装mysql</title>
    <link href="/2022/06/28/%E6%9D%82%E9%A1%B9/brew%E5%AE%89%E8%A3%85mysql/"/>
    <url>/2022/06/28/%E6%9D%82%E9%A1%B9/brew%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install mysql //安装mysql<br><br>brew services start mysql //启动mysql<br>brew services restart mysql //重启mysql<br>brew services stop mysql //停止mysql<br><br>mysql_secure_installation //默认安装没有密码，设置密码(设置密码123456)<br>mysql -uroot [-p] //连接数据库 -p输入密码<br><br>//默认端口3306<br><br>mysqld --<span class="hljs-built_in">help</span> --verbose //查看mysql配置信息<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Express</title>
    <link href="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/"/>
    <url>/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/</url>
    
    <content type="html"><![CDATA[<h2 id="express">Express</h2><h3 id="目标">0 目标</h3><ul><li>能够使用 express.static() 快速托管静态资源</li><li>能够使用 express 路由精简项目结构</li><li>能够使用常见的 express 中间件</li><li>能够使用 express 创建 API 接口</li><li>能够在 express 中启用 cors 跨域资源共享</li></ul><h3 id="初识-express">1. 初识 Express</h3><h4 id="express-简介">1.1 Express 简介</h4><h5 id="什么是-express">1. 什么是 Express</h5><p>官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</p><p>通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。</p><p><strong>Express</strong> <strong>的本质</strong>：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。</p><p>Express 的中文官网：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a></p><h5 id="进一步理解-express">2. 进一步理解 Express</h5><p>思考：不使用 Express 能否创建 Web 服务器？</p><p>答案：能，使用 Node.js 提供的原生 http 模块即可。</p><p>思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？</p><p>答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。</p><p>思考：http 内置模块与 Express 是什么关系？</p><p>答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。</p><h5 id="express-能做什么">3. Express 能做什么</h5><p>对于前端程序员来说，最常见的两种服务器，分别是：</p><ul><li>Web 网站服务器：专门对外提供 Web 网页资源的服务器。</li><li>API 接口服务器：专门对外提供 API 接口的服务器。</li></ul><p>使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。</p><h4 id="express-的基本使用">1.2 Express 的基本使用</h4><h5 id="安装">1. 安装</h5><p>在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628153902437.png" class=""><h5 id="创建基本的-web-服务器">2. 创建基本的 Web 服务器</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628153910942.png" class=""><h5 id="监听-get-请求">3. 监听 GET 请求</h5><p>通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628153922853.png" class=""><h5 id="监听-post-请求">4. 监听 POST 请求</h5><p>通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628153935829.png" class=""><h5 id="把内容响应给客户端">5. 把内容响应给客户端</h5><p>通过 res.send() 方法，可以把处理好的内容，发送给客户端：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628153952125.png" class=""><h5 id="获取-url-中携带的查询参数">6. 获取 URL 中携带的查询参数</h5><p>通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154002735.png" class=""><h5 id="获取-url-中的动态参数">7. 获取 URL 中的动态参数</h5><p>通过 req.params 对象，可以访问到 URL 中，通过 <strong>:</strong> 匹配到的动态参数：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154015614.png" class=""><h4 id="托管静态资源">1.3 托管静态资源</h4><h5 id="express.static">1. express.static()</h5><p>express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154033881.png" class=""><p>现在，你就可以访问 public 目录中的所有文件了：</p><p>http://localhost:3000/images/bg.jpg</p><p>http://localhost:3000/css/style.css</p><p>http://localhost:3000/js/login.js</p><p><strong>注意：</strong>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。</p><p>因此，存放静态文件的目录名不会出现在 URL 中。</p><h5 id="托管多个静态资源目录">2. 托管多个静态资源目录</h5><p>如果要托管多个静态资源目录，请多次调用 express.static() 函数：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154112263.png" class=""><p>访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。</p><h5 id="挂载路径前缀">3. 挂载路径前缀</h5><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154128150.png" class=""><p>现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：</p><p>http://localhost:3000/public/images/kitten.jpg</p><p>http://localhost:3000/public/css/style.css</p><p>http://localhost:3000/public/js/app.js</p><h5 id="nodemon">1.4 nodemon</h5><h5 id="为什么要使用-nodemon">1 为什么要使用 nodemon</h5><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。</p><p>现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。</p><h5 id="安装-nodemon">2. 安装 nodemon</h5><p>在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154204499.png" class=""><h5 id="使用-nodemon">3. 使用 nodemon</h5><p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。</p><p>现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154216567.png" class=""><h3 id="express-路由">2. Express 路由</h3><h4 id="路由的概念">2.1 路由的概念</h4><h5 id="什么是路由">1 什么是路由</h5><p>广义上来讲，路由就是映射关系。</p><h5 id="现实生活中的路由">2. 现实生活中的路由</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154301841.png" class=""><h5 id="express-中的路由">3. Express 中的路由</h5><p>在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。</p><p>Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154316382.png" class=""><h5 id="express-中的路由的例子">4. Express 中的路由的例子</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154335027.png" class=""><h5 id="路由的匹配过程">5 路由的匹配过程</h5><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。</p><p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154358810.png" class=""><h4 id="路由的使用">2.2 路由的使用</h4><h5 id="最简单的用法">1. 最简单的用法</h5><p>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154417338.png" class=""><h5 id="模块化路由">2. 模块化路由</h5><p>为了方便对路由进行模块化的管理，Express <strong>不建议</strong>将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。</p><p>将路由抽离为单独模块的步骤如下：</p><p>①创建路由模块对应的 .js 文件</p><p>②调用 express.Router() 函数创建路由对象</p><p>③向路由对象上挂载具体的路由</p><p>④使用 module.exports 向外共享路由对象</p><p>⑤使用 app.use() 函数注册路由模块</p><h5 id="创建路由模块">3. 创建路由模块</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154436999.png" class=""><h5 id="注册路由模块">4. 注册路由模块</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154444886.png" class=""><h5 id="为路由模块添加前缀">5. 为路由模块添加前缀</h5><p>类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154455507.png" class=""><h3 id="express-中间件">3. Express 中间件</h3><h4 id="中间件的概念">3.1 中间件的概念</h4><h5 id="什么是中间件">1. 什么是中间件</h5><p>中间件（Middleware ），特指业务流程的中间处理环节。</p><h5 id="现实生活中的例子">2. 现实生活中的例子</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154535703.png" class=""><h5 id="express-中间件的调用流程">3. Express 中间件的调用流程</h5><p>当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154552192.png" class=""><h5 id="express-中间件的格式">4. Express 中间件的格式</h5><p>Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154607244.png" class=""><p>注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。</p><h5 id="next-函数的作用">5 next 函数的作用</h5><p><strong>next</strong> <strong>函数</strong>是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154628312.png" class=""><h4 id="express-中间件的初体验">3.2 Express 中间件的初体验</h4><h5 id="定义中间件函数">1. 定义中间件函数</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154641826.png" class=""><h5 id="全局生效的中间件">2. 全局生效的中间件</h5><p>客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。</p><p>通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154657192.png" class=""><h5 id="定义全局中间件的简化形式">3. 定义全局中间件的简化形式</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154708519.png" class=""><h5 id="中间件的作用">4. 中间件的作用</h5><p>多个中间件之间，<strong>共享同一份</strong> <strong>req</strong> <strong>和</strong> <strong>res</strong>。基于这样的特性，我们可以在上游的中间件中，<strong>统一</strong>为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154722494.png" class=""><h5 id="定义多个全局中间件">5. 定义多个全局中间件</h5><p>可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154735284.png" class=""><h5 id="局部生效的中间件">6. 局部生效的中间件</h5><p>不使用 app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154746125.png" class=""><h5 id="定义多个局部中间件">7. 定义多个局部中间件</h5><p>可以在路由中，通过如下两种等价的方式，使用多个局部中间件：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154800054.png" class=""><h5 id="了解中间件的5个使用注意事项">8 了解中间件的5个使用注意事项</h5><p>①一定要在路由之前注册中间件</p><p>②客户端发送过来的请求，可以连续调用多个中间件进行处理</p><p>③执行完中间件的业务代码之后，不要忘记调用 next() 函数</p><p>④为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</p><p>⑤连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</p><h4 id="中间件的分类">3.3 中间件的分类</h4><p>为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：</p><p>① 应用级别的中间件</p><p>② 路由级别的中间件</p><p>③ 错误级别的中间件</p><p>④ Express 内置的中间件</p><p>⑤ 第三方的中间件</p><h5 id="应用级别的中间件">1. 应用级别的中间件</h5><p>通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628154958045.png" class=""><h5 id="路由级别的中间件">2. 路由级别的中间件</h5><p>绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155009960.png" class=""><h5 id="错误级别的中间件">3. 错误级别的中间件</h5><p>错误级别中间件的<strong>作用</strong>：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。</p><p><strong>格式</strong>：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155021749.png" class=""><p><strong>注意：</strong>错误级别的中间件，必须注册在所有路由之后！</p><h5 id="express内置的中间件">4. Express内置的中间件</h5><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><p>① express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</p><p>② express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</p><p>③ express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155050626.png" class=""><h5 id="第三方的中间件">5. 第三方的中间件</h5><p>非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。</p><p>例如：在 express@4.16.0 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下：</p><p>①运行 npm install body-parser 安装中间件</p><p>②使用 require 导入中间件</p><p>③调用 app.use() 注册并使用中间件</p><p><strong>注意：</strong>Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。</p><h4 id="自定义中间件">3.4 自定义中间件</h4><h5 id="需求描述与实现步骤">1. 需求描述与实现步骤</h5><p>自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。</p><p>实现步骤：</p><p>①定义中间件</p><p>②监听 req 的 data 事件</p><p>③监听 req 的 end 事件</p><p>④使用 querystring 模块解析请求体数据</p><p>⑤将解析出来的数据对象挂载为 req.body</p><p>⑥将自定义中间件封装为模块</p><h5 id="定义中间件">2. 定义中间件</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155142985.png" class=""><h5 id="监听-req-的-data-事件">3. 监听 req 的 data 事件</h5><p>在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。</p><p>如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155153968.png" class=""><h5 id="监听-req-的-end-事件">4. 监听 req 的 end 事件</h5><p>当请求体数据接收完毕之后，会自动触发 req 的 end 事件。</p><p>因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155204946.png" class=""><h5 id="使用-querystring-模块解析请求体数据">5. 使用 querystring 模块解析请求体数据</h5><p>Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155219485.png" class=""><h5 id="将解析出来的数据对象挂载为-req.body">6. 将解析出来的数据对象挂载为 req.body</h5><p>上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155231615.png" class=""><h5 id="将自定义中间件封装为模块">7 将自定义中间件封装为模块</h5><p>为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155249010.png" class=""><h3 id="使用-express-写接口">4. 使用 Express 写接口</h3><h4 id="创建基本的服务器">4.1 创建基本的服务器</h4><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155314233.png" class=""><h4 id="创建-api-路由模块"><strong>4.2</strong> <strong>创建</strong> <strong>API</strong> <strong>路由模块</strong></h4><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155321523.png" class=""><h4 id="编写-get-接口"><strong>4.3</strong> <strong>编写</strong> <strong>GET</strong> <strong>接口</strong></h4><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155332503.png" class=""><h4 id="编写-post-接口">4.4 编写 POST 接口</h4><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155353031.png" class=""><p>注意：如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 app.use(express.urlencoded({ extended: false }))</p><h4 id="cors-跨域资源共享">4.5 CORS 跨域资源共享</h4><h5 id="接口的跨域问题">1. 接口的跨域问题</h5><p>刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。</p><p>解决接口跨域问题的方案主要有两种：</p><p>① CORS（主流的解决方案，推荐使用）</p><p>② JSONP（有缺陷的解决方案：只支持 GET 请求）</p><h5 id="使用-cors-中间件解决跨域问题">2. 使用 cors 中间件解决跨域问题</h5><p>cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。</p><p>使用步骤分为如下 3 步：</p><p>①运行 npm install cors 安装中间件</p><p>②使用 const cors = require('cors') 导入中间件</p><p>③在路由之前调用 app.use(cors()) 配置中间件</p><h5 id="什么是-cors">3. 什么是 CORS</h5><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，<strong>这些</strong> <strong>HTTP</strong> <strong>响应头决定浏览器是否阻止前端</strong> <strong>JS</strong> <strong>代码跨域获取资源</strong>。</p><p>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155441177.png" class=""><h5 id="cors-的注意事项">4. CORS 的注意事项</h5><p>①CORS 主要在服务器端进行配置。客户端浏览器<strong>无须做任何额外的配置</strong>，即可请求开启了 CORS 的接口。</p><p>②CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</p><h5 id="cors-响应头部---access-control-allow-origin">5. CORS 响应头部 - Access-Control-Allow-Origin</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155502207.png" class=""><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155516145.png" class=""><h5 id="cors-响应头部---access-control-allow-headers">6. CORS 响应头部 - Access-Control-Allow-Headers</h5><p>默认情况下，CORS <strong>仅</strong>支持客户端向服务器发送如下的 9 个请求头：</p><p>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</p><p>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155530656.png" class=""><h5 id="cors-响应头部---access-control-allow-methods">7. CORS 响应头部 - Access-Control-Allow-Methods</h5><p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。</p><p>如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。</p><p>示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155541563.png" class=""><h5 id="cors请求的分类">8. CORS请求的分类</h5><p>客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是：</p><p>①简单请求</p><p>②预检请求</p><h5 id="简单请求">9. 简单请求</h5><p>同时满足以下两大条件的请求，就属于简单请求：</p><p>① 请求方式：GET、POST、HEAD 三者之一</p><p>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</p><h5 id="预检请求">10. 预检请求</h5><p>只要符合以下任何一个条件的请求，都需要进行预检请求：</p><p>① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型</p><p>② 请求头中包含自定义头部字段</p><p>③ 向服务器发送了 application/json 格式的数据</p><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><h5 id="简单请求和预检请求的区别">11. 简单请求和预检请求的区别</h5><p><strong>简单请求的特点</strong>：客户端与服务器之间只会发生一次请求。</p><p><strong>预检请求的特点</strong>：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p><h4 id="jsonp-接口">4.6 JSONP 接口</h4><h5 id="回顾-jsonp-的概念与特点">1. 回顾 JSONP 的概念与特点</h5>概念：浏览器端通过<script><p>标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP。</p><p>特点：</p><p>①JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。</p><p>②JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。</p><h5 id="创建-jsonp-接口的注意事项">2. 创建 JSONP 接口的注意事项</h5><p>如果项目中已经配置了 CORS 跨域资源共享，为了<strong>防止冲突</strong>，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155643814.png" class=""><h5 id="实现-jsonp-接口的步骤">3. 实现 JSONP 接口的步骤</h5><p>①获取客户端发送过来的回调函数的名字</p><p>②得到要通过 JSONP 形式发送给客户端的数据</p><p>③根据前两步得到的数据，拼接出一个函数调用的字符串</p>④把上一步拼接得到的字符串，响应给客户端的<script><p>标签进行解析执行</p><h5 id="实现-jsonp-接口的具体代码">4. 实现 JSONP 接口的具体代码</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155730078.png" class=""><h5 id="在网页中使用-jquery-发起-jsonp-请求">5. 在网页中使用 jQuery 发起 JSONP 请求</h5><p>调用 $.ajax() 函数，提供 JSONP 的配置选项，从而发起 JSONP 请求，示例代码如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/Express/image-20220628155740354.png" class="">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="模块化">模块化</h2><h3 id="目标">0 目标</h3><ul><li>能够说出模块化的好处</li><li>能够知道 CommonJS 规定了哪些内容</li><li>能够说出 Node.js 中模块的三大分类各自是什么</li><li>能够使用 npm 管理包</li><li>能够了解什么是规范的包结构</li><li>能够了解模块的加载机制</li></ul><h3 id="模块化的基本概念">1. 模块化的基本概念</h3><h4 id="什么是模块化">1.1 什么是模块化</h4><p><strong>模块化</strong>是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。</p><p>编程领域中的模块化，就是<strong>遵守固定的规则</strong>，把一个大文件拆成独立并互相依赖的多个小模块。</p><p>把代码进行模块化拆分的好处：</p><p>①提高了代码的复用性</p><p>②提高了代码的可维护性</p><p>③可以实现按需加载</p><h4 id="模块化规范">1.2 模块化规范</h4><p><strong>模块化规范</strong>就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。</p><p>例如：</p><ul><li>使用什么样的语法格式来引用模块</li><li>在模块中使用什么样的语法格式向外暴露成员</li></ul><p><strong>模块化规范的好处</strong>：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</p><h3 id="node.js-中的模块化">2. Node.js 中的模块化</h3><h4 id="node.js-中模块的分类">2.1 Node.js 中模块的分类</h4><p>Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：</p><ul><li>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</li><li>自定义模块（用户创建的每个 .js 文件，都是自定义模块）</li><li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</li></ul><h4 id="加载模块">2.2 加载模块</h4><p>使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145330186.png" class=""><p>注意：使用 require() 方法加载其它模块时，会执行被加载模块中的代码。</p><h4 id="node.js-中的模块作用域">2.3 Node.js 中的模块作用域</h4><h5 id="什么是模块作用域">1. 什么是模块作用域</h5><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做<strong>模块作用域</strong>。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145406719.png" class=""><h5 id="模块作用域的好处">2. 模块作用域的好处</h5><p>防止了全局变量污染的问题</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145442859.png" class=""><h4 id="向外共享模块作用域中的成员">2.4 向外共享模块作用域中的成员</h4><h5 id="module-对象">1. module 对象</h5><p>在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145502616.png" class=""><h5 id="module.exports-对象">2. module.exports 对象</h5><p>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。</p><p>外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。</p><h5 id="共享成员时的注意点">3. 共享成员时的注意点</h5><p>使用 require() 方法导入模块时，导入的结果，<strong>永远以</strong> <strong>module.exports</strong> <strong>指向的对象为准</strong>。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145522908.png" class=""><h5 id="exports-对象">4. exports 对象</h5><p>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145535052.png" class=""><h5 id="exports-和-module.exports-的使用误区">4. exports 和 module.exports 的使用误区</h5><p>时刻谨记，require() 模块时，得到的永远是 module.exports 指向的对象：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628145607392.png" class=""><p><strong>注意：</strong>为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports</p><h4 id="node.js-中的模块化规范">2.5 Node.js 中的模块化规范</h4><p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。</p><p>CommonJS 规定：</p><p>①每个模块内部，module 变量代表当前模块。</p><p>②module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</p><p>③加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。</p><h3 id="npm与包">3. npm与包</h3><h4 id="包">3.1 包</h4><h5 id="什么是包">1. 什么是包</h5><p>Node.js 中的第三方模块又叫做包。</p><p>就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。</p><h5 id="包的来源">2. 包的来源</h5><p>不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。</p><p><strong>注意</strong>：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。</p><h5 id="为什么需要包">3. 为什么需要包</h5><p>由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。</p><p>包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。</p><p>包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系。</p><h5 id="从哪里下载包">4. 从哪里下载包</h5><p>国外有一家 IT 公司，叫做 <strong>npm, Inc.</strong> 这家公司旗下有一个非常著名的网站： https://www.npmjs.com/ ，它是<strong>全球最大的包共享平台</strong>，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！</p><p>到目前位置，全球约 1100 多万的开发人员，通过这个包共享平台，开发并共享了超过 120 多万个包 供我们使用。</p><p><strong>npm, Inc.</strong> <strong>公司</strong>提供了一个地址为 https://registry.npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。</p><p><strong>注意：</strong></p><ul><li>从 https://www.npmjs.com/ 网站上搜索自己所需要的包</li><li>从 https://registry.npmjs.org/ 服务器上下载自己需要的包</li></ul><h5 id="如何下载包">5. 如何下载包</h5><p><strong>npm, Inc.</strong> <strong>公司</strong>提供了一个包管理工具，我们可以使用这个包管理工具，从 https://registry.npmjs.org/ 服务器把需要的包下载到本地使用。</p><p>这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。</p><p>大家可以在终端中执行 <strong>npm -v</strong> 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150158708.png" class=""><h4 id="npm-初体验">3.2 npm 初体验</h4><h5 id="格式化时间的传统做法">1. 格式化时间的传统做法</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150222187.png" class=""><h5 id="格式化时间的高级做法">2. 格式化时间的高级做法</h5><p>①使用 npm 包管理工具，在项目中安装格式化时间的包 moment</p><p>②使用 require() 导入格式化时间的包</p><p>③参考 moment 的官方 API 文档对时间进行格式化</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150321040.png" class=""><h4 id="在项目中安装包的命令">3. 在项目中安装包的命令</h4><p>如果想在项目中安装指定名称的包，需要运行如下的命令：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150400382.png" class=""><p>上述的装包命令，可以简写成如下格式：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150406561.png" class=""><h5 id="初次装包后多了哪些文件">4. 初次装包后多了哪些文件</h5><p>初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。</p><p>其中：</p><p>node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。</p><p>package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</p><p>注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。</p><h5 id="安装指定版本的包">5. 安装指定版本的包</h5><p>默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本，例如：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150440375.png" class=""><h5 id="包的语义化版本规范">6. 包的语义化版本规范</h5><p>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 <strong>2.24.0</strong></p><p>其中每一位数字所代表的的含义如下：</p><p>第1位数字：大版本</p><p>第2位数字：功能版本</p><p>第3位数字：Bug修复版本</p><p>版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。</p><h4 id="包管理配置文件">3.3 包管理配置文件</h4><p>npm 规定，在项目根目录中，<strong>必须</strong>提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息。例如：</p><ul><li>项目的名称、版本号、描述等</li><li>项目中都用到了哪些包</li><li>哪些包只在开发期间会用到</li><li>那些包在开发和部署时都需要用到</li></ul><h5 id="多人协作的问题">1. 多人协作的问题</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150529540.png" class=""><h5 id="如何记录项目中安装了哪些包">2. 如何记录项目中安装了哪些包</h5><p>在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。</p><p>注意：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。</p><h5 id="快速创建-package.json">3. 快速创建 package.json</h5><p>npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150609347.png" class=""><p>注意：</p><p>①上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。</p><p>②运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。</p><h5 id="dependencies-节点">4. dependencies 节点</h5><p>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。</p><h5 id="一次性安装所有的包">5. 一次性安装所有的包</h5><p>当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。</p><p>否则会报类似于下面的错误：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150647133.png" class=""><p>可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包：</p><h5 id="卸载包">6. 卸载包</h5><p>可以运行 npm uninstall 命令，来卸载指定的包：</p><p>注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。</p><h5 id="devdependencies-节点">7. devDependencies 节点</h5><p>如果某些包<strong>只在项目开发阶段</strong>会用到，在<strong>项目上线之后不会用到</strong>，则建议把这些包记录到 devDependencies 节点中。</p><p>与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。</p><p>您可以使用如下的命令，将包记录到 devDependencies 节点中：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150728661.png" class=""><h4 id="解决下包速度慢的问题">3.4 解决下包速度慢的问题</h4><h5 id="为什么下包速度慢">1. 为什么下包速度慢</h5><p>在使用 npm 下包的时候，默认从国外的 https://registry.npmjs.org/ 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。</p><p>扩展阅读 - 海底光缆：</p><p><a href="https://baike.baidu.com/item/海底光缆/4107830">https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830</a></p><p><a href="https://baike.baidu.com/item/中美海底光缆/10520363">https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363</a></p><p>https://baike.baidu.com/item/APG/23647721?fr=aladdin</p><h5 id="淘宝-npm-镜像服务器">2. 淘宝 NPM 镜像服务器</h5><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150911368.png" class=""><h5 id="切换-npm-的下包镜像源">3. 切换 npm 的下包镜像源</h5><p>下包的镜像源，指的就是下包的服务器地址。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628150935695.png" class=""><h5 id="nrm">4. nrm</h5><p>为了更方便的切换下包的镜像源，我们可以安装 <strong>nrm</strong> 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628151101118.png" class=""><h4 id="包的分类">3.5 包的分类</h4><p>使用 npm 包管理工具下载的包，共分为两大类，分别是：</p><ul><li>项目包</li><li>全局包</li></ul><h5 id="项目包">1. 项目包</h5><p>那些被安装到项目的 node_modules 目录中的包，都是项目包。</p><p>项目包又分为两类，分别是：</p><ul><li>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</li><li>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li></ul><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628151318545.png" class=""><h5 id="全局包">2. 全局包</h5><p>在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。</p><p>全局包会被安装到 C:_modules 目录下。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628151527577.png" class=""><p>注意：</p><p>①只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</p><p>②判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</p><h5 id="i5ting_toc">3. i5ting_toc</h5><p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下：</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628151547666.png" class=""><h4 id="规范的包结构">3.6 规范的包结构</h4><p>在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。</p><p>一个规范的包，它的组成结构，必须符合以下 3 点要求：</p><p>①包必须以单独的目录而存在</p><p>②包的顶级目录下要必须包含 package.json 这个包管理配置文件</p><p>③package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。</p><p>注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：</p><p>https://yarnpkg.com/zh-Hans/docs/package-json</p><h4 id="开发属于自己的包">3.7 开发属于自己的包</h4><h5 id="需要实现的功能">1. 需要实现的功能</h5><p>① 格式化日期</p><p>② 转义 HTML 中的特殊字符</p><p>③ 还原 HTML 中的特殊字符</p><h5 id="初始化包的基本结构">2. 初始化包的基本结构</h5><p>①新建 itheima-tools 文件夹，作为包的根目录</p><p>②在 itheima-tools 文件夹中，新建如下三个文件：</p><ul><li>package.json （包管理配置文件）</li><li>index.js （包的入口文件）</li><li>README.md （包的说明文档）</li></ul><ol start="3" type="1"><li><h5 id="初始化-package.json">初始化 package.json</h5></li></ol><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628153428183.png" class=""><p>关于更多 license 许可协议相关的内容，可参考 https://www.jianshu.com/p/86251523e898</p><h4 id="发布包">3.8 发布包</h4><h5 id="注册-npm-账号">1. 注册 npm 账号</h5><p>①访问 https://www.npmjs.com/ 网站，点击 sign up 按钮，进入注册用户界面</p><p>②填写账号相关的信息：Full Name、Public Email、Username、Password</p><p>③点击 Create an Account 按钮，注册账号</p><p>④登录邮箱，点击验证链接，进行账号的验证</p><h5 id="登录-npm-账号">2. 登录 npm 账号</h5><p>npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。</p><img src="/2022/06/28/%E5%89%8D%E7%AB%AF/Node/%E6%A8%A1%E5%9D%97%E5%8C%96/image-20220628152549855.png" class=""><h5 id="把包发布到-npm-上">3. 把包发布到 npm 上</h5><p>将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。</p><h5 id="删除已发布的包">4. 删除已发布的包</h5><p>运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。</p><p>注意：</p><p>①npm unpublish 命令只能删除 72 小时以内发布的包</p><p>②npm unpublish 删除的包，在 24 小时内不允许重复发布</p><p>③发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！</p><h3 id="模块的加载机制">4. 模块的加载机制</h3><h4 id="优先从缓存中加载">4.1 优先从缓存中加载</h4><p><strong>模块在第一次加载后会被缓存</strong>。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。</p><p>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p><h4 id="内置模块的加载机制">4.2 内置模块的加载机制</h4><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。</p><p>例如，require('fs') 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p><h4 id="自定义模块的加载机制">4.3 自定义模块的加载机制</h4><p>使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p><p>同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p><p>①按照确切的文件名进行加载</p><p>②补全 .js 扩展名进行加载</p><p>③补全 .json 扩展名进行加载</p><p>④补全 .node 扩展名进行加载</p><p>⑤加载失败，终端报错</p><h4 id="第三方模块的加载机制">4.4 第三方模块的加载机制</h4><p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。</p><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</p><p>例如，假设在 'C:.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找：</p><p>① C:_modules</p><p>② C:_modules</p><p>③ C:_modules</p><p>④ C:_modules</p><h4 id="目录作为模块">4.5 目录作为模块</h4><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：</p><p>①在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</p><p>②如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</p><p>③如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'xxx'</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2022/06/27/%E6%9D%82%E9%A1%B9/Nginx/"/>
    <url>/2022/06/27/%E6%9D%82%E9%A1%B9/Nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="常用命令">常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx//启动nginx<br><br>nginx -s stop//停止nginx服务<br>nginx -s reload//重新加载配置文件<br><br>nginx -t //查看配置文件目录<br><br>nginx -c [配置文件路径] //使用新的配置文件<br></code></pre></td></tr></table></figure><h2 id="配置文件">配置文件</h2><h2 id="内网穿透未测试">内网穿透（未测试）</h2><p>公网服务器nginx配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br><br>    listen       80;<br>    server_name dev.test.com;        // 改为你的域名即可<br><br>    location / &#123;<br>        proxy_pass http://127.0.0.1:8080;  // 开放一个本地端口，用来转发上面定义的 80 端口的内容<br>        proxy_redirect off;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header Cookie $http_cookie;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>内网服务器ssh命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -CNg -R 8080:127.0.0.1:8080 -o TCPKeepAlive=<span class="hljs-built_in">yes</span> -o ServerAliveInterval=10 -o ServerAliveCountMax=2 -o ExitOnForwardFailure=<span class="hljs-built_in">yes</span> root@dev.test.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初识Node.js与内置模块</title>
    <link href="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="初识node.js与内置模块">初识Node.js与内置模块</h2><h3 id="目标">0 目标</h3><ul><li>能够知道什么是 Node.js</li><li>能够知道 Node.js 可以做什么</li><li>能够说出 Node.js 中的 JavaScript 的组成部分</li><li>能够使用 fs 模块读写操作文件</li><li>能够使用 path 模块处理路径</li><li>能够使用 http 模块写一个基本的 web 服务器</li></ul><h3 id="初识-node.js">1 初识 Node.js</h3><h4 id="回顾与思考">1.1 回顾与思考</h4><h5 id="已经掌握了哪些技术">1. 已经掌握了哪些技术</h5><ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul><h5 id="浏览器中的-javascript-的组成部分">2. 浏览器中的 JavaScript 的组成部分</h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220627170709289.png" class=""><h5 id="思考为什么-javascript-可以在浏览器中被执行">3. 思考：为什么 JavaScript 可以在浏览器中被执行</h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220627170833578.png" class=""><h5 id="思考为什么-javascript-可以操作-dom-和-bom">4. 思考：为什么 JavaScript 可以操作 DOM 和 BOM</h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220627170853990.png" class=""><ol start="5" type="1"><li><h5 id="浏览器中的-javascript-运行环境">浏览器中的 JavaScript 运行环境</h5></li></ol><p>运行环境是指<strong>代码正常运行所需的必要环境</strong>。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220627170953287.png" class=""><h5 id="思考javascript-能否做后端开发">6. 思考：JavaScript 能否做后端开发</h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220627171034946.png" class=""><h4 id="node.js-简介">1.2 Node.js 简介</h4><h5 id="什么是-node.js">1. 什么是 Node.js</h5><p>Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</p><p>Node.js 的官网地址： https://nodejs.org/zh-cn/</p><h5 id="node.js-中的-javascript-运行环境">2. Node.js 中的 JavaScript 运行环境</h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220627171145019.png" class=""><h5 id="node.js-可以做什么">3. Node.js 可以做什么</h5><p>Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位： 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</p><p>总之：Node.js 是大前端时代的“大宝剑”，有了 Node.js 这个超级 buff 的加持，前端程序员的行业竞争力会越来越强！</p><h5 id="node.js-怎么学">4. Node.js 怎么学</h5><p>浏览器中的 JavaScript 学习路径： JavaScript 基础语法 + 浏览器内置 API（DOM + BOM） + 第三方库（jQuery、art-template 等）</p><p>Node.js 的学习路径： JavaScript 基础语法 + Node.js 内置 API 模块（fs、path、http等）+ 第三方 API 模块（express、mysql 等）</p><h4 id="什么是-fs-文件系统模块">2.1 什么是 fs 文件系统模块</h4><p>fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。 例如： fs.readFile() 方法，用来读取指定文件中的内容 fs.writeFile() 方法，用来向指定的文件中写入内容</p><p>如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="读取指定文件中的内容">2.2 读取指定文件中的内容</h4><h5 id="fs.readfile-的语法格式">1. fs.readFile() 的语法格式</h5><p>使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fs.<span class="hljs-title function_">readFile</span>(path[, options], callback)<br></code></pre></td></tr></table></figure><p>参数解读：</p><p>参数1：必选参数，字符串，表示文件的路径。</p><p>参数2：可选参数，表示以什么编码格式来读取文件。</p><p>参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。</p><h5 id="fs.readfile-的示例代码">2. fs.readFile() 的示例代码</h5><p>以 utf8 的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 导入 fs 模块，来操作文件</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 2. 调用 fs.readFile() 方法读取文件</span><br><span class="hljs-comment">//    参数1：读取文件的存放路径</span><br><span class="hljs-comment">//    参数2：读取文件时候采用的编码格式，一般默认指定 utf8</span><br><span class="hljs-comment">//    参数3：回调函数，拿到读取失败和成功的结果  err  dataStr</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./files/11.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-comment">// 2.1 打印失败的结果</span><br>  <span class="hljs-comment">// 如果读取成功，则 err 的值为 null</span><br>  <span class="hljs-comment">// 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;-------&#x27;</span>)<br>  <span class="hljs-comment">// 2.2 打印成功的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="向指定的文件中写入内容">2.3 向指定的文件中写入内容</h4><h5 id="fs.writefile-的语法格式">1. fs.writeFile() 的语法格式</h5><blockquote><p>无法创建不存在的目录</p></blockquote><p>使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fs.<span class="hljs-title function_">writeFile</span>(file, data[, options], callback)<br></code></pre></td></tr></table></figure><p>参数解读：</p><p>参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。</p><p>参数2：必选参数，表示要写入的内容。</p><p>参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。</p><p>参数4：必选参数，文件写入完成后的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 导入 fs 文件系统模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 2. 调用 fs.writeFile() 方法，写入文件的内容</span><br><span class="hljs-comment">//    参数1：表示文件的存放路径</span><br><span class="hljs-comment">//    参数2：表示要写入的内容</span><br><span class="hljs-comment">//    参数3：回调函数</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./files/3.txt&#x27;</span>, <span class="hljs-string">&#x27;ok123&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-comment">// 2.1 如果文件写入成功，则 err 的值等于 null</span><br>  <span class="hljs-comment">// 2.2 如果文件写入失败，则 err 的值等于一个 错误对象</span><br>  <span class="hljs-comment">// console.log(err)</span><br><br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功！&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="动态拼接文件路径名">2.4 动态拼接文件路径名</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">__dirname + <span class="hljs-string">&#x27;/file.txt&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="path路径模块">3 path路径模块</h3><h4 id="什么是path路径模块">3.1 什么是path路径模块</h4><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><p>例如：</p><p>path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串</p><p>path.basename() 方法，用来从路径字符串中，将文件名解析出来</p><p>如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="路径拼接">3.2 路径拼接</h4><h5 id="path.join-的语法格式">1. path.join() 的语法格式</h5><p>使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">path.<span class="hljs-title function_">join</span>([...paths])<br></code></pre></td></tr></table></figure><p>参数解读： ...paths <string> 路径片段的序列 返回值: <string></p><h5 id="path.join-的代码示例">2. path.join() 的代码示例</h5><p>使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628140352107.png" class=""><p>注意：今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。</p><h4 id="获取路径中的文件名">3.3 获取路径中的文件名</h4><h5 id="path.basename-的语法格式">1. path.basename() 的语法格式</h5><p>使用 path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628140427771.png" class=""><p>参数解读： path <string> 必选参数，表示一个路径的字符串 ext <string> 可选参数，表示文件扩展名 返回: <string> 表示路径中的最后一部分</p><h5 id="path.basename-的代码示例">2. path.basename() 的代码示例</h5><p>使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628140449178.png" class=""><h4 id="获取路径中的文件扩展名">3.4 获取路径中的文件扩展名</h4><h5 id="path.extname-的语法格式">1. path.extname() 的语法格式</h5><p>使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628140527335.png" class=""><p>参数解读： path <string>必选参数，表示一个路径的字符串 返回: <string> 返回得到的扩展名字符串</p><h5 id="path.extname-的代码示例">2. path.extname() 的代码示例</h5><p>使用 path.extname() 方法，可以获取路径中的扩展名部分：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628140545084.png" class=""><p>3.5 综合案例</p><blockquote><p>正则处理html文件，将html文件中css和javascript内容提取出来</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.1 导入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-comment">// 1.2 导入 path 模块</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 1.3 定义正则表达式，分别匹配 &lt;style&gt;&lt;/style&gt; 和 &lt;script&gt;&lt;/script&gt; 标签</span><br><span class="hljs-keyword">const</span> regStyle = <span class="hljs-regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span><br><span class="hljs-keyword">const</span> regScript = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span><br><br><span class="hljs-comment">// 2.1 调用 fs.readFile() 方法读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;../素材/index.html&#x27;</span>), <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, dataStr</span>) &#123;<br>  <span class="hljs-comment">// 2.2 读取 HTML 文件失败</span><br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取HTML文件失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 2.3 读取文件成功后，调用对应的三个方法，分别拆解出 css, js, html 文件</span><br>  <span class="hljs-title function_">resolveCSS</span>(dataStr)<br>  <span class="hljs-title function_">resolveJS</span>(dataStr)<br>  <span class="hljs-title function_">resolveHTML</span>(dataStr)<br>&#125;)<br><br><span class="hljs-comment">// 3.1 定义处理 css 样式的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveCSS</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>  <span class="hljs-comment">// 3.2 使用正则提取需要的内容</span><br>  <span class="hljs-keyword">const</span> r1 = regStyle.<span class="hljs-title function_">exec</span>(htmlStr)<br>  <span class="hljs-comment">// 3.3 将提取出来的样式字符串，进行字符串的 replace 替换操作</span><br>  <span class="hljs-keyword">const</span> newCSS = r1[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;&lt;style&gt;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;&lt;/style&gt;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-comment">// 3.4 调用 fs.writeFile() 方法，将提取的样式，写入到 clock 目录中 index.css 的文件里面</span><br>  fs.<span class="hljs-title function_">writeFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./clock/index.css&#x27;</span>), newCSS, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入 CSS 样式失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入样式文件成功！&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 4.1 定义处理 js 脚本的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveJS</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>  <span class="hljs-comment">// 4.2 通过正则，提取对应的 &lt;script&gt;&lt;/script&gt; 标签内容</span><br>  <span class="hljs-keyword">const</span> r2 = regScript.<span class="hljs-title function_">exec</span>(htmlStr)<br>  <span class="hljs-comment">// 4.3 将提取出来的内容，做进一步的处理</span><br>  <span class="hljs-keyword">const</span> newJS = r2[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;&lt;script&gt;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;&lt;/script&gt;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-comment">// 4.4 将处理的结果，写入到 clock 目录中的 index.js 文件里面</span><br>  fs.<span class="hljs-title function_">writeFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./clock/index.js&#x27;</span>), newJS, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入 JavaScript 脚本失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入 JS 脚本成功！&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 5.1 定义处理 HTML 结构的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveHTML</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>  <span class="hljs-comment">// 5.2 将字符串调用 replace 方法，把内嵌的 style 和 script 标签，替换为外联的 link 和 script 标签</span><br>  <span class="hljs-keyword">const</span> newHTML = htmlStr.<span class="hljs-title function_">replace</span>(regStyle, <span class="hljs-string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; /&gt;&#x27;</span>).<span class="hljs-title function_">replace</span>(regScript, <span class="hljs-string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span>)<br>  <span class="hljs-comment">// 5.3 写入 index.html 这个文件</span><br>  fs.<span class="hljs-title function_">writeFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./clock/index.html&#x27;</span>), newHTML, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入 HTML 文件失败！&#x27;</span> + err.<span class="hljs-property">message</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入 HTML 页面成功！&#x27;</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="http-模块">4. http 模块</h3><h4 id="什么是-http-模块">4.1 什么是 http 模块</h4><p>回顾：什么是客户端、什么是服务器？</p><p>在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。</p><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。</p><p>如果要希望使用 http 模块创建 Web 服务器，则需要先导入它：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628142422259.png" class=""><h4 id="进一步理解-http-模块的作用">4.2 进一步理解 http 模块的作用</h4><p>服务器和普通电脑的<strong>区别</strong>在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。</p><p>在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的 http 模块，<strong>通过几行简单的代码，就能轻松的手写一个服务器软件</strong>，从而对外提供 web 服务。</p><h4 id="服务器相关的概念">4.3 服务器相关的概念</h4><h5 id="ip-地址">1. IP 地址</h5><p><strong>IP</strong> <strong>地址</strong>就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。</p><p>IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）</p><p>注意：</p><p>①<strong>互联网中每台</strong> <strong>Web</strong> <strong>服务器，都有自己的</strong> <strong>IP</strong> <strong>地址</strong>，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。</p><p>②在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。</p><h5 id="域名和域名服务器">2. 域名和域名服务器</h5><p>尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。</p><p>IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做<strong>域名服务器</strong>(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，<strong>域名服务器就是提供</strong> <strong>IP</strong> <strong>地址和域名之间的转换服务的服务器</strong>。</p><p>注意：</p><p>①单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。</p><p>②在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。</p><h5 id="端口号">3. 端口号</h5><p>计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。</p><p>同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628142636633.png" class=""><h4 id="创建最基本的-web-服务器">4.4 创建最基本的 web 服务器</h4><h5 id="创建-web-服务器的基本步骤">1. 创建 web 服务器的基本步骤</h5><p>①导入 http 模块</p><p>②创建 web 服务器实例</p><p>③为服务器实例绑定 <strong>request</strong> 事件，监听客户端的请求</p><p>④启动服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><span class="hljs-comment">// 3. 为服务器实例绑定 request 事件，监听客户端的请求</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Someone visit our web server.&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 4. 启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8081</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8081&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="req-请求对象"><strong>3.</strong> <strong>req</strong> <strong>请求对象</strong></h5><p>只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。</p><p>如果想在事件处理函数中，访问与客户端相关的<strong>数据</strong>或<strong>属性</strong>，可以使用如下的方式：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628143020187.png" class=""><h5 id="res-响应对象"><strong>4.</strong> <strong>res</strong> <strong>响应对象</strong></h5><p>在服务器的 request 事件处理函数中，如果想访问与服务器相关的<strong>数据</strong>或<strong>属性</strong>，可以使用如下的方式：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628143146624.png" class=""><h5 id="解决中文乱码问题">5 解决中文乱码问题</h5><p>当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628143228481.png" class=""><h4 id="根据不同的-url-响应不同的-html-内容">4.5 根据不同的 url 响应不同的 html 内容</h4><p><strong>1.</strong> <strong>核心实现步骤</strong></p><p>①获取请求的 url 地址</p><p>②设置默认的响应内容为 404 Not found</p><p>③判断用户请求的是否为 / 或 /index.html 首页</p><p>④判断用户请求的是否为 /about.html 关于页面</p><p>⑤设置 Content-Type 响应头，防止中文乱码</p><p>⑥使用 res.end() 把内容响应给客户端</p><ol start="2" type="1"><li><h5 id="响应动态内容">响应动态内容</h5></li></ol><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/Node/%E5%88%9D%E8%AF%86Node.js%E4%B8%8E%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/image-20220628143350830.png" class=""><h4 id="案例---实现-clock-时钟的-web-服务器">4.6 案例 - 实现 clock 时钟的 web 服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.1 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 1.2 导入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-comment">// 1.3 导入 path 模块</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 2.1 创建 web 服务器</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><span class="hljs-comment">// 2.2 监听 web 服务器的 request 事件</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 3.1 获取到客户端请求的 URL 地址</span><br>  <span class="hljs-comment">//     /clock/index.html</span><br>  <span class="hljs-comment">//     /clock/index.css</span><br>  <span class="hljs-comment">//     /clock/index.js</span><br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// 3.2 把请求的 URL 地址映射为具体文件的存放路径</span><br>  <span class="hljs-comment">// const fpath = path.join(__dirname, url)</span><br>  <span class="hljs-comment">// 5.1 预定义一个空白的文件存放路径</span><br>  <span class="hljs-keyword">let</span> fpath = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    fpath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./clock/index.html&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//     /index.html</span><br>    <span class="hljs-comment">//     /index.css</span><br>    <span class="hljs-comment">//     /index.js</span><br>    fpath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;/clock&#x27;</span>, url)<br>  &#125;<br><br>  <span class="hljs-comment">// 4.1 根据“映射”过来的文件路径读取文件的内容</span><br>  fs.<span class="hljs-title function_">readFile</span>(fpath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, dataStr</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 4.2 读取失败，向客户端响应固定的“错误消息”</span><br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not found.&#x27;</span>)<br>    <span class="hljs-comment">// 4.3 读取成功，将读取成功的内容，响应给客户端</span><br>    res.<span class="hljs-title function_">end</span>(dataStr)<br>  &#125;)<br>&#125;)<br><span class="hljs-comment">// 2.3 启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax加强</title>
    <link href="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/Ajax%E5%8A%A0%E5%BC%BA/"/>
    <url>/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/Ajax%E5%8A%A0%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="ajax加强">Ajax加强</h2><h3 id="目标">0 目标</h3><ul><li>能够知道如何使用XMLHttpRequest发起Ajax请求</li><li>能够知道如何封装自己的Ajax函数</li><li>能够使用XMLHttpRequest Level2中提供的新特性</li><li>能够知道jQuery中如何实现文件上传与loading效果</li><li>能够知道如何使用axios发起Ajax请求</li></ul><h3 id="xmlhttprequest的基本使用">1 XMLHttpRequest的基本使用</h3><h4 id="什么是xmlhttprequest"><strong>1.1</strong> 什么是XMLHttpRequest</h4><p>XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源。之前所学的 jQuery 中的 Ajax 函数，就是基于 xhr 对象封装出来的。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/Ajax%E5%8A%A0%E5%BC%BA/image-20220627142731451.png" class=""><h4 id="使用xhr发起get请求">1.2 使用xhr发起GET请求</h4><p>步骤：</p><p>①创建 xhr 对象</p><p>②调用 xhr.open() 函数</p><p>③调用 xhr.send() 函数</p><p>④监听 xhr.onreadystatechange 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建 XHR 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">// 2. 调用 open 函数，指定 请求方式 与 URL地址</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)<br><span class="hljs-comment">// 3. 调用 send 函数，发起 Ajax 请求</span><br>xhr.<span class="hljs-title function_">send</span>()<br><span class="hljs-comment">// 4. 监听 onreadystatechange 事件</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status</span><br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-comment">// 4.2 打印服务器响应回来的数据</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="了解xhr对象的readystate属性">1.3 了解xhr对象的readyState属性</h4><p>XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态。每个 Ajax 请求必然处于以下状态中的一个：</p><table><thead><tr class="header"><th><strong>值</strong></th><th><strong>状态</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td>0</td><td>UNSENT</td><td>XMLHttpRequest 对象已被创建，但尚未调用 open方法。</td></tr><tr class="even"><td>1</td><td>OPENED</td><td>open() 方法已经被调用。</td></tr><tr class="odd"><td>2</td><td>HEADERS_RECEIVED</td><td>send() 方法已经被调用，响应头也已经被接收。</td></tr><tr class="even"><td>3</td><td>LOADING</td><td>数据接收中，此时 response 属性中已经包含部分数据。</td></tr><tr class="odd"><td>4</td><td>DONE</td><td>Ajax 请求完成，这意味着数据传输已经彻底完成或失败。</td></tr></tbody></table><h4 id="使用xhr发起带参数的get请求">1.4 使用xhr发起带参数的GET请求</h4><p>使用 xhr 对象发起带参数的 GET 请求时，只需在调用 xhr.open 期间，为 URL 地址指定参数即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...省略不必要的代码</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&#x27;</span>)<br><span class="hljs-comment">// ...省略不必要的代码</span><br></code></pre></td></tr></table></figure><p>这种在 URL 地址后面拼接的参数，叫做<strong>查询字符串</strong>。</p><h4 id="查询字符串">1.5 查询字符串</h4><h5 id="什么是查询字符串">1. 什么是查询字符串</h5><p>定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）。</p><p>格式：将英文的 <strong>?</strong> 放在URL 的末尾，然后再加上 <strong>参数＝值</strong> ，想加上多个参数的话，使用 <strong>&amp;</strong> 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到 URL 中。</p><p>// 不带参数的 URL 地址 http://www.liulongbin.top:3006/api/getbooks // 带一个参数的 URL 地址 http://www.liulongbin.top:3006/api/getbooks?id=1 // 带两个参数的 URL 地址 http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记</p><h5 id="get请求携带参数的本质">2. GET请求携带参数的本质</h5><p>无论使用 $.ajax()，还是使用 $.get()，又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;)<br><span class="hljs-comment">// 等价于</span><br>$.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;url?name=zs&amp;age=20&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;)<br><br>$.<span class="hljs-title function_">ajax</span>(&#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attr">data</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;, <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;)<br><span class="hljs-comment">// 等价于</span><br>$.<span class="hljs-title function_">ajax</span>(&#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url?name=zs&amp;age=20&#x27;</span>, <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; &#125;)<br><br></code></pre></td></tr></table></figure><h4 id="url编码与解码">1.6 URL编码与解码</h4><h5 id="什么是url编码">1. 什么是URL编码</h5><p>URL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，在 URL 地址中不允许出现中文字符。 如果 URL 中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。 URL编码的原则：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。 URL编码原则的通俗理解：使用英文字符去表示非英文字符。</p><p>http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记 // 经过 URL 编码之后，URL地址变成了如下格式： http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0</p><h5 id="如何对url进行编码与解码">2. 如何对URL进行编码与解码</h5><p>浏览器提供了 URL 编码与解码的 API，分别是：</p><p>lencodeURI() 编码的函数</p><p>ldecodeURI() 解码的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">&#x27;黑马程序员&#x27;</span>)<br><span class="hljs-comment">// 输出字符串  %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98</span><br><span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&#x27;%E9%BB%91%E9%A9%AC&#x27;</span>)<br><span class="hljs-comment">// 输出字符串  黑马</span><br></code></pre></td></tr></table></figure><h5 id="url编码的注意事项">3. URL编码的注意事项</h5><p>由于浏览器会自动对 URL 地址进行编码操作，因此，大多数情况下，程序员不需要关心 URL 地址的编码与解码操作。</p><p>更多关于 URL 编码的知识，请参考如下博客： https://blog.csdn.net/Lxd_0111/article/details/78028889</p><h4 id="使用xhr发起post请求">1.7 使用xhr发起POST请求</h4><p>步骤：</p><p>①创建 xhr 对象</p><p>②调用 xhr.open() 函数</p><p>③<strong>设置</strong> <strong>Content-Type</strong> <strong>属性</strong>（固定写法）</p><p>④调用 xhr.send() 函数，<strong>同时指定要发送的数据</strong></p><p>⑤监听 xhr.onreadystatechange 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建 xhr 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">// 2. 调用 open()</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>)<br><span class="hljs-comment">// 3. 设置 Content-Type 属性（固定写法）</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)<br><span class="hljs-comment">// 4. 调用 send()，同时将数据以查询字符串的形式，提交给服务器</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社&#x27;</span>)<br><span class="hljs-comment">// 5. 监听 onreadystatechange 事件</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据交换格式">2. 数据交换格式</h3><h4 id="什么是数据交换格式">2.1 什么是数据交换格式</h4><p>数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。</p><p>前端领域，经常提及的两种数据交换格式分别是 XML 和 JSON。其中 XML 用的非常少，所以，我们重点要学习的数据交换格式就是 JSON。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/Ajax%E5%8A%A0%E5%BC%BA/image-20220627143337589.png" class=""><h4 id="xml">2.2 XML</h4><h5 id="什么是xml">1. 什么是XML</h5><p>XML 的英文全称是 E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage，即<strong>可扩展标记语言</strong>。因此，XML 和 HTML 类似，也是一种标记语言。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/Ajax%E5%8A%A0%E5%BC%BA/image-20220627143407200.png" class=""><h5 id="xml和html的区别">2. XML和HTML的区别</h5><p>XML 和 HTML 虽然都是标记语言，但是，它们两者之间没有任何的关系。</p><p>lHTML 被设计用来描述网页上的<strong>内容</strong>，是网页内容的载体</p><p>lXML 被设计用来<strong>传输和存储数据</strong>，是数据的载体</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/Ajax%E5%8A%A0%E5%BC%BA/image-20220627143429173.png" class=""><h5 id="xml的缺点">3. XML的缺点</h5><p>①XML 格式臃肿，和数据无关的代码多，体积大，传输效率低</p><p>②在 Javascript 中解析 XML 比较麻烦</p><h4 id="json">2.3 JSON</h4><h5 id="什么是json">1. 什么是JSON</h5><p>概念：JSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象表示法”。简单来讲，JSON 就是 Javascript 对象和数组的字符串表示法，它使用文本表示一个 JS 对象或数组的信息，因此，<strong>JSON</strong> <strong>的本质是字符串</strong>。</p><p>作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析。</p><p>现状：JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式。</p><h5 id="json的两种结构">2. JSON的两种结构</h5><p>JSON 就是用字符串来表示 Javascript 的对象和数组。所以，JSON 中包含<strong>对象</strong>和<strong>数组</strong>两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。</p><ul><li><strong>对象结构</strong>：对象结构在 JSON 中表示为 { } 括起来的内容。数据结构为 { key: value, key: value, … } 的键值对结构。其中，key 必须是使用英文的双引号包裹的字符串，value 的数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zs&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;男&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">null</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hobby&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;吃饭&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;睡觉&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;打豆豆&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>数组结构</strong>：数组结构在 JSON 中表示为 [ ] 括起来的内容。数据结构为 [ "java", "javascript", 30, true … ] 。数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;java&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;python&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;php&quot;</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span> <span class="hljs-number">200</span><span class="hljs-punctuation">,</span> <span class="hljs-number">300.5</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">null</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zs&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ls&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">[</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;苹果&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;榴莲&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;椰子&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">[</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-number">50</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span> <span class="hljs-punctuation">]</span> <span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h5 id="json语法注意事项">3. JSON语法注意事项</h5><p>①属性名必须使用双引号包裹</p><p>②字符串类型的值必须使用双引号包裹</p><p>③JSON 中不允许使用单引号表示字符串</p><p>④JSON 中不能写注释</p><p>⑤JSON 的最外层必须是对象或数组格式</p><p>⑥不能使用 undefined 或函数作为 JSON 的值</p><p>JSON 的作用：在计算机与网络之间存储和传输数据。</p><p>JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据</p><h5 id="json和js对象的关系">4. JSON和JS对象的关系</h5><p>JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//这是一个对象</span><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;<br><br><span class="hljs-comment">//这是一个 JSON 字符串，本质是一个字符串</span><br><span class="hljs-keyword">var</span> json = <span class="hljs-string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span> <br></code></pre></td></tr></table></figure><h5 id="json和js对象的互转">5. JSON和JS对象的互转</h5><p>要实现从 JSON 字符串转换为 JS 对象，使用 JSON.parse() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>)<br><span class="hljs-comment">//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>要实现从 JS 对象转换为 JSON 字符串，使用 JSON.stringify() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br><span class="hljs-comment">//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="序列化和反序列化">6. 序列化和反序列化</h5><p>把数据对象转换为字符串的过程，叫做<strong>序列化</strong>，例如：调用 JSON.stringify() 函数的操作，叫做 JSON 序列化。</p><p>把字符串转换为数据对象的过程，叫做<strong>反序列化</strong>，例如：调用 JSON.parse() 函数的操作，叫做 JSON 反序列化。</p><h3 id="封装自己的ajax函数">3. 封装自己的Ajax函数</h3><h3 id="xmlhttprequest-level2的新特性">4. XMLHttpRequest Level2的新特性</h3><h4 id="认识xmlhttprequest-level2">4.1 认识XMLHttpRequest Level2</h4><h5 id="旧版xmlhttprequest的缺点">1. 旧版XMLHttpRequest的缺点</h5><p>①只支持文本数据的传输，无法用来读取和上传文件</p><p>②传送和接收数据时，没有进度信息，只能提示有没有完成</p><h5 id="xmlhttprequest-level2的新功能">2. XMLHttpRequest Level2的新功能</h5><p>①可以设置 HTTP 请求的时限</p><p>②可以使用 FormData 对象管理表单数据</p><p>③可以上传文件</p><p>④可以获得数据传输的进度信息</p><h4 id="设置http请求时限">4.2 设置HTTP请求时限</h4><p>有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>上面的语句，将最长等待时间设为 3000 毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个 timeout 事件，用来指定回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请求超时！&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="formdata对象管理表单数据">4.3 FormData对象管理表单数据</h4><p>Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">      <span class="hljs-comment">// 1. 新建 FormData 对象</span><br>      <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>      <span class="hljs-comment">// 2. 为 FormData 添加表单项</span><br>      fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-string">&#x27;zs&#x27;</span>)<br>      fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;upwd&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br>      <span class="hljs-comment">// 3. 创建 XHR 对象</span><br>      <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>      <span class="hljs-comment">// 4. 指定请求类型与URL地址</span><br>      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)<br>      <span class="hljs-comment">// 5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样</span><br>      xhr.<span class="hljs-title function_">send</span>(fd)<br></code></pre></td></tr></table></figure><p>FormData对象也可以用来获取网页表单的值，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// 获取表单元素</span><br> <span class="hljs-keyword">var</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#form1&#x27;</span>)<br> <span class="hljs-comment">// 监听表单元素的 submit 事件</span><br> form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>()<br>     <span class="hljs-comment">// 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中</span><br>     <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form)<br>     <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>     xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)<br>     xhr.<span class="hljs-title function_">send</span>(fd)<br>     xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="上传文件">4.4 上传文件</h4><p>新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。</p><p>实现步骤：</p><p>①定义 UI 结构</p><p>②验证是否选择了文件</p><p>③向 FormData 中追加文件</p><p>④使用 xhr 发起上传文件的请求</p><p>⑤监听 onreadystatechange 事件</p><h5 id="定义ui结构">1. 定义UI结构</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-comment">&lt;!-- 1. 文件选择框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file1&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2. 上传按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnUpload&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 3. 显示上传到服务器上的图片 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h5 id="验证是否选择了文件">2. 验证是否选择了文件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 获取上传文件的按钮</span><br><span class="hljs-keyword">var</span> btnUpload = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btnUpload&#x27;</span>)<br><span class="hljs-comment">// 2. 为按钮添加 click 事件监听</span><br>btnUpload.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 3. 获取到选择的文件列表</span><br>    <span class="hljs-keyword">var</span> files = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#file1&#x27;</span>).<span class="hljs-property">files</span><br>    <span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择要上传的文件！&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// ...后续业务逻辑</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><h5 id="向formdata中追加文件">3. 向FormData中追加文件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建 FormData 对象</span><br><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br><span class="hljs-comment">// 2. 向 FormData 中追加文件</span><br>fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h5 id="使用-xhr-发起上传文件的请求">4. 使用 xhr 发起上传文件的请求</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建 xhr 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">// 2. 调用 open 函数，指定请求类型与URL地址。其中，请求类型必须为 POST</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>)<br><span class="hljs-comment">// 3. 发起请求</span><br>xhr.<span class="hljs-title function_">send</span>(fd)<br></code></pre></td></tr></table></figure><h5 id="监听onreadystatechange事件">5. 监听onreadystatechange事件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)<br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123; <span class="hljs-comment">// 上传文件成功</span><br>      <span class="hljs-comment">// 将服务器返回的图片地址，设置为 &lt;img&gt; 标签的 src 属性</span><br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#img&#x27;</span>).<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006&#x27;</span> + data.<span class="hljs-property">url</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 上传文件失败</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">message</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="显示文件上传进度">4.5 显示文件上传进度</h4><p>新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// 创建 XHR 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br><span class="hljs-comment">// 监听 xhr.upload 的 onprogress 事件</span><br>xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>   <span class="hljs-comment">// e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度</span><br>   <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;<br>       <span class="hljs-comment">// e.loaded 已传输的字节</span><br>       <span class="hljs-comment">// e.total  需传输的总字节</span><br>       <span class="hljs-keyword">var</span> percentComplete = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jquery高级用法">5. jQuery高级用法</h3><h3 id="axios">6. axios</h3><h4 id="什么是axios">6.1 什么是axios</h4><p>Axios 是专注于<strong>网络数据请求</strong>的库。</p><p>相比于原生的 XMLHttpRequest 对象，axios <strong>简单易用</strong>。</p><p>相比于 jQuery，axios 更加<strong>轻量化</strong>，只专注于网络数据请求。</p><h4 id="axios发起get请求">6.2 axios发起GET请求</h4><p>axios 发起 get 请求的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-comment">/*参数*/</span> &#125; &#125;).<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><p>具体的请求示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 请求的 URL 地址</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span><br><span class="hljs-comment">// 请求的参数对象</span><br><span class="hljs-keyword">var</span> paramsObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<br><span class="hljs-comment">// 调用 axios.get() 发起 GET 请求</span><br>axios.<span class="hljs-title function_">get</span>(url, &#123; <span class="hljs-attr">params</span>: paramsObj &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-comment">// res.data 是服务器返回的数据</span><br>    <span class="hljs-keyword">var</span> result = res.<span class="hljs-property">data</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="axios发起post请求">6.3 axios发起POST请求</h4><p>axios 发起 post 请求的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-comment">/*参数*/</span> &#125;).<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><p>具体的请求示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 请求的 URL 地址</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span><br><span class="hljs-comment">// 要提交到服务器的数据</span><br><span class="hljs-keyword">var</span> dataObj = &#123; <span class="hljs-attr">location</span>: <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;顺义&#x27;</span> &#125;<br><span class="hljs-comment">// 调用 axios.post() 发起 POST 请求</span><br>axios.<span class="hljs-title function_">post</span>(url, dataObj).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-comment">// res.data 是服务器返回的数据</span><br>    <span class="hljs-keyword">var</span> result = res.<span class="hljs-property">data</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="直接使用axios发起请求">6.4 直接使用axios发起请求</h4><p>axios 也提供了类似于 jQuery 中 $.ajax() 的函数，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;请求类型&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;请求的URL地址&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-comment">/* POST数据 */</span> &#125;,<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-comment">/* GET参数 */</span> &#125;<br>&#125;) .<span class="hljs-title function_">then</span>(callback)<br></code></pre></td></tr></table></figure><h5 id="直接使用axios发起get请求">1. 直接使用axios发起GET请求</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;<br>     <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>     <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>,<br>     <span class="hljs-attr">params</span>: &#123; <span class="hljs-comment">// GET 参数要通过 params 属性提供</span><br>         <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>         <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>     &#125;<br> &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br> &#125;)<br></code></pre></td></tr></table></figure><h5 id="直接使用axios发起post请求">2. 直接使用axios发起POST请求</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">axios</span>(&#123;<br>     <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>     <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>,<br>     <span class="hljs-attr">data</span>: &#123; <span class="hljs-comment">// POST 数据要通过 data 属性提供</span><br>         <span class="hljs-attr">bookname</span>: <span class="hljs-string">&#x27;程序员的自我修养&#x27;</span>,<br>         <span class="hljs-attr">price</span>: <span class="hljs-number">666</span><br>     &#125;<br> &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br> &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议加强</title>
    <link href="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/"/>
    <url>/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="http协议加强">HTTP协议加强</h2><h3 id="学习目标">0 学习目标</h3><ul><li>能够说出什么是HTTP协议</li><li>能够知道HTTP请求消息的组成部分</li><li>能够知道HTTP响应消息的组成部分</li><li>能够说出常见的请求方法</li><li>能够说出常见的响应状态码</li></ul><h3 id="http协议简介">1 HTTP协议简介</h3><h4 id="什么是通信"><strong>1.1</strong> <strong>什么是通信</strong></h4><p>通信，就是<strong>信息的传递和交换</strong>。</p><p>通信三要素：</p><ul><li>通信的主体</li><li>通信的内容</li><li>通信的方式</li></ul><h5 id="现实生活中的通信"><strong>1</strong> <strong>现实生活中的通信</strong></h5><p>案例：<strong>张三</strong>要把自己考上传智专修学院的好消息写信告诉自己的好朋友<strong>李四</strong>。</p><p>其中：</p><ul><li>通信的主体是张三和李四；</li><li>通信的内容是考上传智专修学院；</li><li>通信的方式是写信；</li></ul><h5 id="互联网中的通信"><strong>2.</strong> <strong>互联网中的通信</strong></h5><p>案例：服务器把传智专修学院的简介通过响应的方式发送给客户端浏览器。</p><p>其中：</p><ul><li>通信的主体是服务器和客户端浏览器；</li><li>通信的内容是传智专修学院的简介；</li><li>通信的方式是响应；</li></ul><h4 id="什么是通信协议"><strong>1.2</strong> <strong>什么是通信协议</strong></h4><p><strong>通信协议</strong>（Communication Protocol）是指通信的双方完成通信所必须遵守的规则和约定。</p><p>通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。</p><h5 id="现实生活中的通信协议"><strong>1.</strong> <strong>现实生活中的通信协议</strong></h5><p>张三与李四采用写信的方式进行通信，在填写信封时，写信的双方需要遵守固定的规则。信封的填写规则就是一种通信协议。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627114504849.png" class=""><h5 id="互联网中的通信协议"><strong>2.</strong> <strong>互联网中的通信协议</strong></h5><p>客户端与服务器之间要实现网页内容的传输，则通信的双方必须遵守网页内容的传输协议。</p><p>网页内容又叫做<strong>超文本</strong>，因此网页内容的传输协议又叫做<strong>超文本传输协议</strong>（HyperText Transfer Protocol） ，简称 <strong>HTTP</strong> <strong>协议</strong>。</p><h4 id="http"><strong>1.3 HTTP</strong></h4><h5 id="什么是http协议">什么是HTTP协议</h5><p><strong>HTTP</strong> <strong>协议</strong>即超文本传送协议 (HyperText Transfer Protocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p><p>例如：</p><ul><li>客户端要以HTTP协议要求的格式把数据提交到服务器</li><li>服务器要以HTTP协议要求的格式把内容响应给客户端</li></ul><h5 id="http协议的交互模型"><strong>2 HTTP</strong>协议的交互模型</h5><p>HTTP 协议采用了请求/响应的交互模型。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140401225.png" class=""><h3 id="http请求">2 HTTP请求</h3><h4 id="什么是http请求"><strong>2.1</strong> <strong>什么是</strong>HTTP请求</h4><p>由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做 <strong>HTTP</strong> <strong>请求</strong>，客户端发送到服务器的消息，叫做 <strong>HTTP</strong> <strong>请求消息</strong>。</p><p>注意：HTTP 请求消息又叫做 HTTP 请求报文。</p><h4 id="http请求消息的组成部分"><strong>2.2 HTTP</strong>请求消息的组成部分</h4><p>HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140441476.png" class=""><h5 id="请求行"><strong>1.</strong> <strong>请求行</strong></h5><p><strong>请求行</strong>由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140456901.png" class=""><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140500688.png" class=""><h5 id="请求头部"><strong>2.</strong> <strong>请求头部</strong></h5><p><strong>请求头部</strong>用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。</p><p>请求头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140519032.png" class=""><p>常见的请求头字</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140549900.png" class=""><p>关于更多请求头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</p><h5 id="空行"><strong>3.</strong> <strong>空行</strong></h5><p>最后一个请求头字段的后面是一个<strong>空行</strong>，通知服务器请求头部至此结束。</p><p>请求消息中的空行，用来分隔请求头部与请求体。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140616063.png" class=""><h5 id="请求体"><strong>4.</strong> <strong>请求体</strong></h5><p>请求体中存放的，是要通过 POST 方式提交到服务器的数据。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140629259.png" class=""><p><strong>注意</strong>：只有 POST 请求才有请求体，GET 请求没有请求体！</p><h5 id="总结"><strong>5.</strong> <strong>总结</strong></h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140643663.png" class=""><h3 id="http响应">3 HTTP响应</h3><h4 id="什么是http响应"><strong>3.1</strong> <strong>什么是</strong>HTTP响应</h4><p>响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。</p><h4 id="http响应消息的组成部分"><strong>3.2 HTTP</strong>响应消息的组成部分</h4><p>HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示：</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140709082.png" class=""><h5 id="状态行"><strong>1.</strong> <strong>状态行</strong></h5><p><strong>状态行</strong>由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140720111.png" class=""><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140722884-6310043.png" class=""><h5 id="响应头部"><strong>2.</strong> <strong>响应头部</strong></h5><p><strong>响应头部</strong>用来描述服务器的基本信息。响应头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140743553.png" class=""><p>常见的响应头字段</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140756430.png" class=""><p>关于更多响应头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</p><h5 id="空行-1"><strong>3.</strong> <strong>空行</strong></h5><p>在最后一个响应头部字段结束之后，会紧跟一个<strong>空行</strong>，用来通知客户端响应头部至此结束。</p><p>响应消息中的空行，用来分隔响应头部与响应体。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140812801.png" class=""><h5 id="响应体"><strong>4.</strong> <strong>响应体</strong></h5><p>响应体中存放的，是服务器响应给客户端的资源内容。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140829446.png" class=""><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140832981.png" class=""><h5 id="总结-1"><strong>5.</strong> <strong>总结</strong></h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140842555.png" class=""><h3 id="http请求方法">4 HTTP请求方法</h3><h4 id="什么是http请求方法"><strong>4.1</strong> 什么是HTTP请求方法</h4><p>HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。</p><h4 id="http的请求方法"><strong>4.2 HTTP</strong>的请求方法</h4><table><thead><tr class="header"><th><strong>序号</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td>1</td><td>GET</td><td>(查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td></tr><tr class="even"><td>2</td><td>POST</td><td>(新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td></tr><tr class="odd"><td>3</td><td>PUT</td><td>(修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td></tr><tr class="even"><td>4</td><td>DELETE</td><td>(删除)请求服务器删除指定的资源。</td></tr><tr class="odd"><td>5</td><td>HEAD</td><td>HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。</td></tr><tr class="even"><td>6</td><td>OPTIONS</td><td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td></tr><tr class="odd"><td>7</td><td>CONNECT</td><td>建立一个到由目标资源标识的服务器的隧道。</td></tr><tr class="even"><td>8</td><td>TRACE</td><td>沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。</td></tr><tr class="odd"><td>9</td><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h3 id="http响应状态代码">5 HTTP响应状态代码</h3><h4 id="什么是http响应状态码"><strong>5.1</strong> <strong>什么是</strong>HTTP响应状态码</h4><p><strong>HTTP</strong> <strong>响应状态码</strong>（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。</p><p>响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/HTTP%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%BC%BA/image-20220627140937309.png" class=""><h4 id="http响应状态码的组成及分类"><strong>5.2 HTTP</strong>响应状态码的组成及分类</h4><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。</p><p>HTTP 状态码共分为 5 种类型：</p><table><thead><tr class="header"><th><strong>分类</strong></th><th><strong>分类描述</strong></th></tr></thead><tbody><tr class="odd"><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到 1** 类型的状态码）</td></tr><tr class="even"><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr class="odd"><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr class="even"><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr class="odd"><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>完整的 HTTP 响应状态码，可以参考 MDN 官方文档 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</p><h4 id="常见的http响应状态码"><strong>5.3</strong> <strong>常见的</strong>HTTP响应状态码</h4><h5 id="成功相关的响应状态码"><strong>1</strong> <strong>2</strong>** 成功相关的响应状态码</h5><p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p><table><thead><tr class="header"><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr class="odd"><td>200</td><td>OK</td><td>请求成功。一般用于 GET 与 POST 请求</td></tr><tr class="even"><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源，通常用于 POST 或 PUT 请求</td></tr></tbody></table><h5 id="重定向相关的响应状态码"><strong>2</strong> 3** 重定向相关的响应状态码</h5><p>3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p><table><thead><tr class="header"><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr class="odd"><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr class="even"><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr class="odd"><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><h5 id="客户端错误相关的响应状态码">3 <strong>4</strong>*<strong>* 客户端错误相关</strong>的响应状态码</h5><p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p><table><thead><tr class="header"><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr class="odd"><td>400</td><td>Bad Request</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td></tr><tr class="even"><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr class="odd"><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr class="even"><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr class="odd"><td>408</td><td>Request Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table><h5 id="服务端错误相关的响应状态码"><strong>3.</strong> <strong>5</strong>*<strong>* 服务端错误相关</strong>的响应状态码</h5><p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的 5** 类型的状态码如下：</p><table><thead><tr class="header"><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr class="odd"><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr class="even"><td>501</td><td>Not Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有 GET 和 HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr class="odd"><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跨域和JSONP</title>
    <link href="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/"/>
    <url>/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/</url>
    
    <content type="html"><![CDATA[<h2 id="跨域和jsonp">跨域和JSONP</h2><h3 id="学习目标">0 学习目标</h3><ul><li><p>能够知道什么是同源策略和跨域</p></li><li><p>能够知道什么是JSONP</p></li><li><p>能够说出JSONP的实现原理</p></li><li><p>能够知道防抖和节流的概念</p></li></ul><h3 id="了解同源策略与跨域">1 了解同源策略与跨域</h3><h4 id="同源策略">1.1 同源策略</h4><h5 id="什么是同源">1 <strong>什么是</strong>同源</h5><p>如果两个页面的协议，域名和端口都相同，则两个页面具有<strong>相同的源</strong>。</p><p>例如，下表给出了相对于 http://www.test.com/index.html 页面的同源检测：</p><table><thead><tr class="header"><th><strong>URL</strong></th><th><strong>是否同源</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr class="odd"><td>http://www.test.com/other.html</td><td>是</td><td>同源（协议、域名、端口相同）</td></tr><tr class="even"><td>https://www.test.com/about.html</td><td>否</td><td>协议不同（http 与 https）</td></tr><tr class="odd"><td>http://blog.test.com/movie.html</td><td>否</td><td>域名不同（www.test.com 与 blog.test.com）</td></tr><tr class="even"><td>http://www.test.com:7001/home.html</td><td>否</td><td>端口不同（默认的 80 端口与 7001 端口）</td></tr><tr class="odd"><td>http://www.test.com:80/main.html</td><td>是</td><td>同源（协议、域名、端口相同）</td></tr></tbody></table><h5 id="什么是同源策略"><strong>2 </strong>什么是<strong>同源策略</strong></h5><p><strong>同源策略</strong>（英文全称 Same origin policy）是浏览器提供的一个安全功能。</p><p>MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如：</p><p>①无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>②无法接触非同源网页的 DOM</p><p>③无法向非同源地址发送 Ajax 请求</p><h4 id="跨域"><strong>1.2</strong> <strong>跨域</strong></h4><h5 id="什么是跨域"><strong>1</strong> <strong>什么是</strong>跨域</h5><p><strong>同源</strong>指的是两个 URL 的协议、域名、端口一致，反之，则是<strong>跨域</strong>。</p><p>出现跨域的根本原因：<strong>浏览器的同源策略</strong>不允许非同源的 URL 之间进行资源的交互。</p><p>网页：http://www.test.com/index.html</p><p>接口：http://www.api.com/userlist</p><h5 id="浏览器对跨域请求的拦截">2 <strong>浏览器对跨域请求的拦截</strong></h5><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/image-20220627105952950.png" class=""><p>注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！</p><h5 id="如何实现跨域数据请求"><strong>3</strong> <strong>如何实现跨域数据请求</strong></h5><p>现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。</p><p>JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。</p><p>CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。</p><h3 id="jsonp"><strong>2 JSONP</strong></h3><h4 id="什么是jsonp"><strong>2.1</strong> <strong>什么是</strong>JSONP</h4><p>JSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p><h4 id="jsonp的实现原理"><strong>2.2 JSONP</strong>的实现原理</h4>由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是<script><p>标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。</p>因此，JSONP 的实现原理，就是通过<script><p>标签的 src 属性，请求跨域的数据接口，并通过<strong>函数调用</strong>的形式，接收跨域接口响应回来的数据。</p><h4 id="自己实现一个简单的jsonp"><strong>2.3</strong> <strong>自己实现一个简单的</strong>JSONP</h4><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/image-20220627110249368.png" class=""><h4 id="jsonp的缺点"><strong>2.4 JSONP</strong>的缺点</h4>由于 JSONP 是通过<script><p>标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。</p><p>注意：<strong>JSONP</strong> <strong>和</strong> <strong>Ajax</strong> <strong>之间没有任何关系</strong>，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。</p><h4 id="jquery中的jsonp">2.5 jQuery中的<strong>JSONP</strong></h4><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/image-20220627110541452.png" class=""><h4 id="自定义参数及回调函数名称">2.6 <strong>自定义参数及回调函数名称</strong></h4><p>在使用 jQuery 发起 JSONP 请求时，如果想要自定义 JSONP 的<strong>参数</strong>以及<strong>回调函数名称</strong>，可以通过如下两个参数来指定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<br>   <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20&#x27;</span>,<br>   <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,<br>   <span class="hljs-comment">// 发送到服务端的参数名称，默认值为 callback</span><br>   <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;callback&#x27;</span>,<br>   <span class="hljs-comment">// 自定义的回调函数名称，默认值为 jQueryxxx 格式a</span><br>   <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>   <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>   &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h4 id="jquery中jsonp的实现过程">2.7 jQuery<strong>中</strong>JSONP的实现过程</h4>jQuery 中的 JSONP，也是通过<script>标签的 src 属性实现跨域数据访问的，只不过，jQuery 采用的是<strong>动态创建和移除</strong> **<script><p>** <strong>标签</strong>的方式，来发起 JSONP 数据请求。</p>在发起 JSONP 请求的时候，动态向<header>中 append 一个<script><p>标签；</p>在 JSONP 请求成功以后，动态从<header>中移除刚才 append 进去的<script><p>标签；</p><h3 id="防抖和节流">4 <strong>防抖和节流</strong></h3><h4 id="什么是防抖"><strong>4.1</strong> <strong>什么是防抖</strong></h4><p><strong>防抖策略</strong>（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 <img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/image-20220627112250083.png" class=""></p><h4 id="什么是节流"><strong>4.2 </strong>什么是节流</h4><p><strong>节流策略</strong>（throttle），顾名思义，可以减少一段时间内事件的触发频率。</p><img src="/2022/06/27/%E5%89%8D%E7%AB%AF/JavaScript/Ajax/%E8%B7%A8%E5%9F%9F%E5%92%8CJSONP/image-20220627112318329.png" class=""><h4 id="节流的应用场景">4.3 <strong>节流的应用场景</strong></h4><p>①鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；</p><p>②懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源；</p><h4 id="节流案例-鼠标跟随效果"><strong>4.4</strong> <strong>节流案例</strong> <strong>–</strong> <strong>鼠标跟随效果</strong></h4><h4 id="节流阀的概念"><strong>4.5</strong> <strong>节流阀</strong>的概念</h4><p>高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。</p><p>假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。</p><p>上一个人使用完毕后，需要将红灯<strong>重置</strong>为绿灯，表示下一个人可以使用卫生间。</p><p>下一个人在上卫生间之前，需要<strong>先判断控制灯</strong>是否为绿色，来知晓能否上卫生间。</p><p>节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。</p><p>当前操作执行完，必须将节流阀<strong>重置</strong>为空，表示可以执行下次操作了。</p><p>每次执行操作前，必须<strong>先判断节流阀是否为空</strong>。</p><h4 id="总结防抖和节流的区别"><strong>4.6 </strong>总结防抖和节流的区别</h4><p>防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多次的触发都会被忽略！</p><p>节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！</p><h4 id="案例">4.7 案例</h4><ul><li><p>淘宝搜索栏</p></li><li><p>鼠标跟随</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DRY原则</title>
    <link href="/2022/06/16/%E6%9D%82%E9%A1%B9/DRY%E5%8E%9F%E5%88%99/"/>
    <url>/2022/06/16/%E6%9D%82%E9%A1%B9/DRY%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<ul><li>DON'T REPEAT YOUR CODE</li><li>命令级</li><li>命令块级</li><li>设计模式</li><li>框架</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端框架</title>
    <link href="/2022/06/13/%E5%90%8E%E7%AB%AF/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/06/13/%E5%90%8E%E7%AB%AF/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="node.js">1 Node.js</h1><ul><li>Express.js：Node.js诞生初期最早的后端框架</li><li>Nest.js：基于Express.js的框架，结合TypeScript</li><li>Koa.js：ECMAScript诞生后Express团队开发的一款框架，需要自己找中间件</li><li>Egg.js：淘宝基于Koa.js结合生产实践经验给出的框架</li><li>Midway.js：淘宝基于Egg.js基础上，结合TypeScript的框架</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>客户端Web-API</title>
    <link href="/2022/06/13/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AE%A2%E6%88%B7%E7%AB%AFWeb-API/"/>
    <url>/2022/06/13/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AE%A2%E6%88%B7%E7%AB%AFWeb-API/</url>
    
    <content type="html"><![CDATA[<h2 id="qa">1 Q&amp;A</h2><p>Q：什么是API？</p><p>A：应用程序接口（API，Application Programming Interface）是基于编程语言构建的结构，使开发人员更容易地创建复杂的功能。它们抽象了复杂的代码，并提供一些简单的接口规则直接使用。</p><p>Q：为什么需要API？</p><p>A：加速开发，避免造轮子。</p><p>Q：JavaScript和API以及库、框架的关系？</p><p>A：JavaScript，是一种运行于浏览器或者Node.js中的高级语言。</p><p>客户端API，是一种提供高级功能的代码段，可直接调用。</p><p>JavaScript库，是包含特定功能的一个或多个JavaScript文件，引入这些文件可以避免重复实现功能。</p><p>JavaScript框架，将HTML，CSS，JavaScript技术结合在一起，从头开始创建一个Web应用。</p><h2 id="都有哪些api">2 都有哪些API</h2><ul><li>浏览器内置API<ul><li>操作文档：例如DOM，允许脚本操作HTML和CSS。</li><li>从服务器获取数据：例如XMLHttpRequest，Fetch API，允许异步获取数据并局部更新页面。</li><li>用于绘制和操作图形：例如canvas，允许网页中绘制图形</li><li>音频和视频：例如HTMLMediaElement，Web Audio API</li><li>设备 API：检索客户端设备硬件数据，例如Notification，地理API</li><li>客户端存储：保存页面之间加载状态，使应用脱机使用，Web Storage API存储简单键值对, IndexedDB API存储更复杂数据</li></ul></li><li>第三方API<ul><li>Twitter</li><li>Google Maps</li><li>Twilio</li><li><a href="https://www.programmableweb.com/category/all/apis">在此</a>找到更多</li></ul></li></ul><h2 id="javascript中api如何工作">3 JavaScript中API如何工作</h2><ul><li>基于对象，通过对象调用API</li><li>有可识别入口点，可以根据功能来找到被调用的API对象</li><li>可使用事件处理状态变化，例如XMLHttpRequet中，当数据返回时，通过onload异步调用处理函数</li><li>有一定安全机制，例如同源策略等</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node.js</title>
    <link href="/2022/06/13/%E5%89%8D%E7%AB%AF/Node/Node.js/"/>
    <url>/2022/06/13/%E5%89%8D%E7%AB%AF/Node/Node.js/</url>
    
    <content type="html"><![CDATA[<h2 id="qa">1 Q&amp;A</h2><p>Q：什么是Node.js？</p><p>A：一个JavaScript的运行时环境，提供运行时需要的功能，例如文件读写等，使JavaScript可以在浏览器之外的环境里运行。</p><p>Q：什么是npm？</p><p>A：一个JavaScript的包管理器，可以管理本地的功能包，从云端下砸功能包</p><p>Q：什么事npx？</p><p>A：从npm可以下载可执行文件，使用npx可以执行该文件</p><h2 id="事件队列">2 事件队列</h2><ul><li>调用堆栈：LIFO队列，函数调用时使用该队列</li><li>消息队列：当调用堆栈清空，执行消息队列（setTimeout）</li><li>作业队列：当调用者返回后，执行工作队列（Promise）</li></ul><h2 id="process.nexttick">3 process.nextTick()</h2><ul><li>事件循环完成一次历程，成为一次tick</li><li>参数为回调函数</li></ul><h2 id="定时器">4 定时器</h2><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li></ul><h2 id="异步编程">5 异步编程</h2><ul><li>使用回调函数，传入异步API</li><li>使用Promise（避免回调金字塔）<ul><li>新建Promise进入处理种状态，最终状态变为<code>解决</code>或<code>拒绝</code>，并调用相应函数处理</li><li>链式Promise，</li><li>Promise.all，所有Promise都解决执行后续操作</li><li>Promise.race，第一个Promise解决后执行后续操作</li></ul></li><li>使用Async, Await（基于Promise，更高级别抽象）<ul><li></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue框架</title>
    <link href="/2022/06/13/%E5%89%8D%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/"/>
    <url>/2022/06/13/%E5%89%8D%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/</url>
    
    <content type="html"><![CDATA[<h2 id="qa">1 Q&amp;A</h2><p>Q：什么是Vue？</p><p>A：Vue是一个JavaScript框架，不同于MVC模型，Vue给出了MVVC模型的实现，可以简化MVC开发中对Controller的代码编写。</p><p>Q：学习Vue需要提前了解什么？</p><p>A：熟悉核心HTML，CSS和JavaScript语言，了解命令行。</p><p>Q：可以用Vue来做什么？</p><p>A：编写整个SPAs（单页应用程序）</p><h2 id="学习文档">2 学习文档</h2><ul><li>构建</li></ul><h2 id="文件格式">3 文件格式</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>客户端框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端框架概述</title>
    <link href="/2022/06/13/%E5%89%8D%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/06/13/%E5%89%8D%E7%AB%AF/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考自<a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction">Introduction to client-side frameworks</a></p></blockquote><h2 id="qa">1 Q&amp;A</h2><p>Q：为什么需要框架？</p><p>A：没有框架的痛点，例如当处理一个To-List网页应用时，当添加清单、删除清单时，不仅要更新页面，还要更新数据，这两者需要同步，而MVC中Controller就是实现这个功能的桥梁。有了框架，就可以加快打造高度动态化和交互性强的应用程序的速度，框架就是提供这些功能的库。（看个<a href="https://codepen.io/mxmason/pen/XWbPNmw">例子</a>）</p><p>Q：有哪些框架？</p><p>A：Angular（Google，2016），Vue（尤雨溪，2014），React（Facebook，2013）</p><p>Q：什么是路由？</p><p>A：「服务端路由」，指的是通过url引导用户从一个页面到另一个页面，url通过网络结构相互关联，用户可以通过前进后退在浏览历史的url中进行移动。</p><p>现代网络应用一般避请求新的HTML或进行HTML渲染，这类应用在第一次请求时获取一个HTML文件（称这种应用为SPAs，即单页面应用），并通过更新HTML对应的DOM来更新页面，避免用户在服务端请求新的地址，换句话说，就是默认避免了服务端路由过程，我们称每个伪网页为「view」（视图）</p><p>当一个SPAs足够复杂时，在客户端引入路由功能，引导用户从一个视图到另一个视图，这是为了迎合用户在使用服务端路由时习惯了的功能，例如通过超链接到另一个页面，用导航键前后移动浏览历史。只不过这是路由功能由客户端提供，故称这种路由为「客户端路由」</p><h2 id="提供哪些功能方便开发">2 提供哪些功能方便开发</h2><ul><li>简化DOM操作代码</li><li>简化UIs开发</li><li>模块组件化，一个部件的代码放在一起，方便维护</li><li>路由，引导用户从一个页面到另一个页面</li></ul><h2 id="如果前端不需要太多javascript操作">3 如果前端不需要太多Javascript操作</h2><ul><li>考虑内容管理系统（CMSes），直接进行内容管理，避免自己敲代码，但是对最终渲染结果缺少一部分控制权，例如Wordpress</li><li>考虑服务端渲染，直接通过后端渲染出单个HTML页面应用，使用Vue可以考虑Nust.js</li><li>考虑静态内容生成器</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>客户端框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异步JavaScript</title>
    <link href="/2022/06/13/%E5%89%8D%E7%AB%AF/JavaScript/%E5%BC%82%E6%AD%A5/%E5%BC%82%E6%AD%A5JavaScript/"/>
    <url>/2022/06/13/%E5%89%8D%E7%AB%AF/JavaScript/%E5%BC%82%E6%AD%A5/%E5%BC%82%E6%AD%A5JavaScript/</url>
    
    <content type="html"><![CDATA[<h2 id="qa">1 Q&amp;A</h2><p>Q：什么是异步编程？</p><p>A：异步是相对于同步来说的，同步编程意味着程序之间执行顺序是顺次的，异步编程意味着程序执行顺序未知的。</p><p>Q：为什么需要异步编程？</p><p>A：在JavaScript中异步编程是为了解决函数执行时间过长，导致阻塞后面语句的问题。给出的解决方案如下：函数立即返回；当函数处理结束时，通知我们处理结束；可以通过回调函数，对通知进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>异步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习进阶</title>
    <link href="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="自然语言处理">自然语言处理</h1><h2 id="单词含义的表示方法">1 单词含义的表示方法</h2><h3 id="同义词词典wordnet">1.1 同义词词典（WordNet）</h3><ul><li>原理：通过建立单词之间的联系（局部整体、上位下位）来使机器理解单词含义</li><li>缺陷：<ul><li>人工建立单词关系网络成本高</li><li>单词关系变化迅速，人工建立关系网难以及时更新</li><li>难以表示单词之间微妙的联系</li></ul></li></ul><h3 id="计数方法">1.2 计数方法</h3><ul><li><p>原理：</p><ul><li><p>基于语料库（现成的文章）自动提取单词内容（<strong>主流</strong>）</p></li><li><p>用向量表示单词</p></li><li><p><strong>分布式假设</strong>：单词的含义由其周围的单词形成（单词本身没有含义，单词的含义来自于上下文语境）</p></li><li><p>共现矩阵：用其他所有单词在某一单词上下文出现次数形成的矩阵来表示单词</p></li><li><p>余弦相似度：表示不同单词向量之间的相似度</p></li><li><p>点互信息：为了解决the、car之间存在的并非相似含义的高相似性，将单词在文本中出现频率引入相似性的考量范围</p></li><li><p>PPMI矩阵：将点互信息引入共现矩阵</p></li><li><p>向量降维：当单词数量过多时，PPMI矩阵很大，而且因为很多单词之间无关联，故可以保留重要信息的基础上进行向量降维</p><ul><li>将二维数据压缩成为一维数据</li><li>可行性：数据之间关系是重要信息，压缩后数据之间关系信息被大部分保留下来</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220616095618837.png" class=""></li><li>方法：SVG（奇异值分解）、SVG改进方法如：Truncated SVD</li></ul></li></ul></li><li><p>PTB语料库：word2vec发明者提供的语料库，该语料库对原始文本数据进行了预处理</p></li><li><p>缺陷：</p><ul><li>计算量极大</li><li>需要一次输入全部数据</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220616101049059.png" class=""></li></ul></li></ul><h3 id="推理方法word2vec">1.3 推理方法（word2vec）</h3><ul><li>原理：<ul><li>通过上下文，推测当前会出现什么单词</li><li>基本任务：解决上述问题，引入神经网络，输入上下文，给出当前位置可能出现的单词</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220616101512323.png" class=""></li></ul></li><li>神经网络对单词进行编码：<ul><li>ont-hot编码：只有一个数是1，其余均是0</li></ul></li><li>word2vec：<ul><li>原本指的是程序或者工具，如今也指神经网络模型</li><li>CBOW：<ul><li>根据上下文预测目标词的神经网络</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220616102641290.png" class=""></li></ul></li><li>skip-gram：<ul><li>反转了CBOW的任务，从目标词预测上下文</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220616103051899.png" class=""></li></ul></li><li>CBOW学习速度快，skip-gram预测性能更好</li></ul></li></ul><h3 id="计数法和推理法比较">1.4 计数法和推理法比较</h3><ul><li>推理法允许增量处理输入数据</li><li>推理法可以解决<code>king - man +woman = queen</code>这类<strong>推理问题</strong></li><li>就单词相似性而言，两者性能相当</li><li>GloVe 方法，结合了计数法和推理法</li></ul><h3 id="分布式表示好处">1.5 分布式表示好处</h3><ul><li>有利于迁移学习，即将学习得到的分布式表示用在其他应用中</li><li>将单词和文档表示为固定长度向量，可以应用传统机器学习算法进行进一步处理</li></ul><h3 id="应用场景">1.6 应用场景</h3><ul><li>邮件分类</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220616105815062.png" class=""></li></ul><h2 id="循环神经网络">2 循环神经网络</h2><h3 id="rnn和lstm">2.1 RNN和LSTM</h3><ul><li>前馈神经网络的痛点：无法学习时序数据模式</li><li>语言模型：<ul><li>给出一个单词序列，预测该单词序列是否是一个自然语言句子</li><li>应用：机器翻译、语音识别</li><li>CBOW无法考量上下文顺序关系</li></ul></li><li>RNN能记忆上下文信息</li><li>RNN层结构：</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220617112858189.png" class=""></li><li>训练方法：<ul><li>BPTT（基于时间的反向传播）<ul><li>问题：时序数据变长，内存占用增多</li></ul></li><li>Truncated BPTT（反向传播链条适当截断）</li></ul></li><li>痛点：<ul><li>上面的RNN结构十分简单，效果不好</li><li>被LSTM或GRU替代</li></ul></li><li>LSTM：<ul><li>在简单RNN基础上加入了门结构</li><li>基于门可以学习到时序数据的长期依赖关系</li></ul></li><li>梯度消失和梯度爆炸<ul><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220617115040120.png" class=""></li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220617115127417.png" class=""></li><li>梯度爆炸:<ul><li>概念: 随着反向传播的进行,梯度发散,导致无法正确学习</li><li>解决: 梯度裁剪,当梯度大于阈值时,减小梯度值</li></ul></li><li>梯度消失:<ul><li>概念: 随着反向传播的进行,梯度收敛为0,导致无法正常学习</li><li>解决: 需要从根本上改变网络结构,为此,提出了Gated RNN,LSTM就是一种Gated RNN结构</li></ul></li><li>LSTM门结构<ul><li>引入了门的概念,门是指一种对数据进行0-1缩放的结构</li><li>输出门: 对输出进行0-1之间的控制 (其中X为对应元素乘积)</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619145429464.png" class=""></li><li>遗忘门: 删除部分记忆信息</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619145645795.png" class=""></li><li>添加记忆信息</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619145803314.png" class=""></li><li>输入门:</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619145824127.png" class=""></li></ul></li><li>LSTM加深</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619150438964.png" class=""></li><li>抑制过拟合<ul><li>降低模型复杂度</li><li>增加训练数据</li><li>惩罚正则化,惩罚大权重</li><li>使用Dropout<ul><li>常规Dropout用于深度方向</li><li>变分Dropout用于时间方向</li></ul></li></ul></li><li>权重共享:简化学习过程</li></ul></li><li>RNN和LSTM的简单应用<ul><li>文本生成</li><li>seq2seq网络模型, 实现机器翻译、聊天机器人、邮件回复</li><li>学习加法逻辑</li></ul></li><li>seq2seq结构<ul><li>两个RNN,一个充当编码器,一个充当解码器</li><li>优化:<ul><li>反转输入数据训练</li><li>偷窥(Peeky),将编码器输出传递到解码器的每个以时间方向RNN结构中</li></ul></li><li>应用:<ul><li>机器翻译</li><li>自动摘要</li><li>问答系统</li><li>算法学习(源码到输出结果的学习)</li><li>图像描述</li></ul></li></ul></li></ul><h3 id="注意力机制">2.2 注意力机制</h3><ul><li>当前seq2seq存在的问题<ul><li>无论输入数据多长,编码器输出数据长度一定</li></ul></li><li>改进方法<ul><li>编码器改进<ul><li>对编码器各个是个隐藏状态向量进行输出</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619160157195.png" class=""></li><li>双向RNN</li></ul></li><li>解码器改进<ul><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619160820934.png" class=""></li><li>根据隐藏状态判读LSTM和编码器各隐藏状态的相似程度</li><li><img src="/2022/05/12/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20220619162038931.png" class=""></li></ul></li><li>加深层<ul><li>Drop</li><li>权重共享</li><li>残差连接(跨层连接)</li></ul></li></ul></li><li>进一步研究<ul><li>GNMT: 将上述优化全用了</li><li>Transformer: RNN并行化处理</li><li>NTM: 利用了外部记忆功能</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提问的智慧</title>
    <link href="/2022/05/11/%E6%96%B9%E6%B3%95%E8%AE%BA/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <url>/2022/05/11/%E6%96%B9%E6%B3%95%E8%AE%BA/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="提问的智慧">提问的智慧</h1><h4 id="艾瑞克.史蒂文.雷蒙德eric-steven-raymond">艾瑞克.史蒂文.雷蒙德（Eric Steven Raymond）</h4><p>Thyrsus Enterprises</p><p><a href="mailto:esr@thyrsus.com" class="email">esr@thyrsus.com</a> #### 瑞克.莫恩（Rick Moen）</p><p><a href="mailto:respond-auto@linuxmafia.com" class="email">respond-auto@linuxmafia.com</a> 版权©2001, 2006 Eric S. Raymond, Rick Moen</p><h3 id="修订历史">修订历史</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dns">修订版 <span class="hljs-number">3.92013</span>年<span class="hljs-number">4</span>月<span class="hljs-number">23</span>日esr<br>修正链接<br>修订版 <span class="hljs-number">3.82012</span>年<span class="hljs-number">6</span>月<span class="hljs-number">19</span>日esr<br>修正链接<br>修订版 <span class="hljs-number">3.72010</span>年<span class="hljs-number">12</span>月<span class="hljs-number">6</span>日esr<br>对于英语为第二语言人士的有益建议<br>修订版 <span class="hljs-number">3.72010</span>年<span class="hljs-number">11</span>月<span class="hljs-number">2</span>日esr<br>几种翻译不见了<br>修订版 <span class="hljs-number">3.62008</span>年<span class="hljs-number">3</span>月<span class="hljs-number">19</span>日esr<br>小更新及新链接<br>修订版 <span class="hljs-number">3.52008</span>年<span class="hljs-number">1</span>月<span class="hljs-number">2</span>日esr<br>勘误及一些翻译链接<br>修订版 <span class="hljs-number">3.42007</span>年<span class="hljs-number">3</span>月<span class="hljs-number">24</span>日esr<br>新章节：“关于代码的问题”<br>修订版 <span class="hljs-number">3.32006</span>年<span class="hljs-number">9</span>月<span class="hljs-number">29</span>日esr<br>增加凯.尼格曼（Kai Niggemann）的一个好建议<br>修订版 <span class="hljs-number">3.22006</span>年<span class="hljs-number">1</span>月<span class="hljs-number">10</span>日esr<br>加入瑞克.莫恩（Rick Moen）编写的内容<br>修订版 <span class="hljs-number">3.12004</span>年<span class="hljs-number">10</span>月<span class="hljs-number">28</span>日esr<br>文档“谷歌是你的朋友！”<br>修订版 <span class="hljs-number">3.02004</span>年<span class="hljs-number">2</span>月<span class="hljs-number">2</span>日esr<br>主要新增在网页论坛应有的礼节<br></code></pre></td></tr></table></figure><h3 id="原文how-to-ask-questions-the-smart-way"><a href="http://www.catb.org/~esr/faqs/smart-questions.html">原文：How To Ask Questions The Smart Way</a></h3><p>翻译：王刚 &lt;yafrank at 126 dot com &gt;<br />时间：2013年10月26日 内容</p><h3 id="目录">目录</h3><ul><li><a href="#弃权申明">弃权申明</a></li><li><a href="#引言">引言</a></li><li><a href="#提问前">提问前</a></li><li><a href="#提问时">提问时</a><ul><li><a href="#仔细挑选论坛">仔细挑选论坛</a></li><li><a href="#面向新手的论坛和互联网中继聊天irc通常响应最快">面向新手的论坛和互联网中继聊天（IRC）通常响应最快</a></li><li><a href="#第二步使用项目的邮件列表">第二步，使用项目的邮件列表</a></li><li><a href="#使用有意义且明确的主题">使用有意义且明确的主题</a></li><li><a href="#使问题容易回复">使问题容易回复</a></li><li><a href="#用清晰语法拼写正确的语句书写">用清晰、语法、拼写正确的语句书写</a></li><li><a href="#使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#描述问题应准确且有内容">描述问题应准确且有内容</a></li><li><a href="#量不在多精炼则灵">量不在多，精炼则灵</a></li><li><a href="#别急于宣称找到Bug">别急于宣称找到Bug</a></li><li><a href="#低声下气代替不了做自己的家庭作业">低声下气代替不了做自己的家庭作业</a></li><li><a href="#描述问题症状而不是猜测">描述问题症状而不是猜测</a></li><li><a href="#按时间先后罗列问题症状">按时间先后罗列问题症状</a></li><li><a href="#描述目标而不是过程">描述目标而不是过程</a></li><li><a href="#别要求私下回复电邮">别要求私下回复电邮</a></li><li><a href="#提问应明确">提问应明确</a></li><li><a href="#关于代码的问题">关于代码的问题</a></li><li><a href="#别张贴家庭作业式问题">别张贴家庭作业式问题</a></li><li><a href="#删除无意义的要求">删除无意义的要求</a></li><li><a href="#不要把问题标记为紧急即使对你而言的确如此">不要把问题标记为“紧急”，即使对你而言的确如此</a></li><li><a href="#礼貌总是有益的">礼貌总是有益的</a></li><li><a href="#礼貌总是有益的">问题解决后追加一条简要说明</a></li></ul></li><li><a href="#如何解读回答">如何解读回答</a><ul><li><a href="#读读该死的手册rtfm和搜搜该死的网络stfw如何明白你已完全搞砸">“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸</a></li><li><a href="#如果还不明白">如果还不明白……</a></li><li><a href="#对待无礼">对待无礼</a></li></ul></li><li><a href="#别象失败者那样反应">别象失败者那样反应</a></li><li><a href="#别象失败者那样反应">提问禁忌</a></li><li><a href="#好问题与坏问题">好问题与坏问题</a></li><li><a href="#如果得不到回答">如果得不到回答</a></li><li><a href="#如何更好地回答">如何更好地回答</a></li><li><a href="#相关资源">相关资源</a></li><li><a href="#鸣谢">鸣谢</a></li></ul><blockquote><p>译文： 印尼语 白俄罗斯语 巴西葡萄牙语 简体中文 荷兰语 法语 乔治亚语 德语 希腊语 希伯来语 日语 波兰语 葡萄牙语 罗马尼亚语 俄语 西班牙语 泰语 如果你想复制、镜像、翻译或引用本文，请参阅我的 复制协议。</p></blockquote><h3 id="弃权申明">弃权申明</h3><p>许多项目的网站在如何取得帮助的部分链接了本文，这没有关系，也正是我们想要的。但如果你是该项目生成此链接的网管，请在链接附近显著位置注明：我们不提供该项目的服务支持！</p><p>我们已经领教了没有此说明带来的痛苦，我们将不停地被一些白痴纠缠，他们认为既然我们发布了本文，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要帮助正在阅读本文，然后就带着可以直接从作者那取得帮助的印象离开，那么 你 就不幸成了我们所说的白痴之一。 别向 我们 提问，我们不会理睬的。 我们只是在这教你如何从那些真正懂得你软硬件问题的人那里取得帮助，但 99.9％ 的时间我们不会是那些人。除非你非常地 确定 本文的作者是你遇到问题方面的专家，请不要打搅，这样大家都更开心一点。</p><h3 id="引言">引言</h3><p>在 黑客 的世界里，你所提技术问题的解答很大程度上取决于你提问的方式与解决此问题的难度，本文将教你如何提问才更有可能得到满意的答复。</p><p>开源程序的应用已经很广，你通常可以从其他更有经验的用户而不是黑客那里得到解答。这是好事，他们一般对新手常有的毛病更容忍一点。然尔，使用我们推荐的方法，象对待黑客那样对待这些有经验的用户，通常能最有效地得到问题的解答。</p><p>第一件需要明白的事是黑客喜欢难题和激发思考的好问题。假如不是这样，我们也不会写本文了。如果你能提出一个有趣的问题让我们咀嚼玩味，我们会感激你。好问题是种激励与礼物，帮助我们发展认知，揭示没有注意或想到的问题。在黑客中，“好问题！” 是非常热烈而真挚的赞许。</p><p>此外，黑客还有遇到简单问题就表现出敌视或傲慢的名声。有时，我们看起来还对新手和愚蠢的家伙有条件反射式的无礼，但事情并不真是这样。</p><p>我们只是毫无歉意地敌视那些提问前不愿思考、不做自己家庭作业的人。这种人就象时间无底洞──他们只知道索取，不愿意付出，他们浪费了时间，这些时间本可用于其它更有趣的问题或更值得回答的人。我们将这种人叫做 “失败者（loser）” （由于历史原因，我们有时将“loser”拼写为“lusers” 。）</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，计算机只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做，我们承认这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。不过，我们回答问题的风格是为了适应那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就会在自己能做得最好的事情上不再那么犀利。</p><p>我们（大多数）是自愿者， 从自己繁忙的生活中抽时间来回答问题，有时会力不从心。因此，我们会毫不留情地滤除问题，特别是那些看起来象是失败者提的，以便更有效地把回答问题的时间留给那些胜利者。</p><p>如果你认为这种态度令人反感、以施惠者自居或傲慢自大，请检查你的假设，我们并未要求你屈服──事实上，假如你做了该做的努力，我们中的大多数将非常乐意平等地与你交流，并欢迎你接纳我们的文化。试图去帮助那些不愿自救的人对我们简直没有效率。不懂没有关系，但愚蠢地做事不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你 必须 表现出能引导你在行的姿态──机 敏、有想法、善于观察、乐于主动参与问题的解决。如果你做不到这些使你与众不同的事情，我们建议你付钱跟别人签商业服务合同，而不是要求黑客无偿帮助。</p><p>如果你决定向我们求助，你不会想成为一名失败者，你也不想被看成一个失败者。得到快速有效回答的最好方法是使提问者看起来象个聪明、自信和有想法的人，并且暗示只是碰巧在某一特别问题上需要帮助。</p><p>（欢迎对本文指正，可以将建议发至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。 请注意，本文不想成为一般性的 网络礼仪 指南，我一般会拒绝那些与引出技术论坛中有用的回答不特别相关的建议。）</p><h3 id="提问前">提问前</h3><p>在通过电邮、新闻组或论坛提技术问题以前，做以下事情：</p><ul><li>尝试在你准备提问论坛的历史文档中搜索答案</li><li>尝试搜索互联网以找到答案</li><li>尝试阅读手册以找到答案</li><li>尝试阅读“常见问题文档”（FAQ）以找到答案</li><li>尝试自己检查或试验以找到答案</li><li>尝试请教懂行的朋友以找到答案</li><li>如果你是程序员，尝试阅读源代码以找到答案</li></ul><p>提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。</p><p>运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。</p><p>别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。</p><p>认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。</p><p>注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。</p><p>永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。</p><p>另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。</p><h3 id="提问时">提问时</h3><h4 id="仔细挑选论坛">仔细挑选论坛</h4><p>要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”：</p><ul><li>张贴与论坛主题无关的问题</li><li>在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。</li><li>在太多不同的新闻组同时张贴</li><li>给既非熟人也没有义务解决你问题的人发送你私人的电邮</li></ul><p>为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。</p><p>因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告Bug的流程或链接，如果是这样，去看看。</p><p>向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。</p><p>在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。</p><p>弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。</p><p>可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。</p><h4 id="面向新手的论坛和互联网中继聊天irc通常响应最快">面向新手的论坛和互联网中继聊天（IRC）通常响应最快</h4><p>本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。</p><p>事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。</p><p>在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。</p><h4 id="第二步使用项目的邮件列表">第二步，使用项目的邮件列表</h4><p>当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由：</p><ul><li>向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。</p><p>然尔，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h4 id="使用有意义且明确的主题">使用有意义且明确的主题</h4><p>在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。</p><p>使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。</p><p>愚蠢： &gt;救命啊！我的笔记本视频工作不正常！</p><p>明智： &gt;X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组</p><p>更明智： &gt;使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲</p><p>编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。</p><p>更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。</p><p>如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 <code>Re: 测试</code> 或者 <code>Re: 新Bug</code> 的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。</p><p>对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。</p><p>在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。</p><h4 id="使问题容易回复">使问题容易回复</h4><p>以<code>请向……回复</code>来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如<code>留意本线索</code>、<code>有回复发送邮件</code>等功能。</p><h4 id="用清晰语法拼写正确的语句书写">用清晰、语法、拼写正确的语句书写</h4><p>经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。</p><p>清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将 <code>its</code> 混淆为 <code>it's</code>，<code>loose</code> 搞成 <code>lose</code> 或者将 “discrete” 弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。）</p><p>一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将 <code>you</code> 简化为 <code>u</code> 会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。</p><p>如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如：</p><ul><li>英语不是我的母语，请谅解拼写错误。</li><li>如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。</li><li>对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。</li><li>我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。</li></ul><h4 id="使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</h4><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li><p>使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难）</p></li><li><p>使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。</p></li><li><p>不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。</p></li><li><p>但是，也 不要 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。</p></li><li><p>在英语论坛中，不要使用'Quoted-Printable' MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。</p></li><li><p>永远不要 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。</p></li><li><p>如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。</p></li><li><p>在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。</p></li><li><p>如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的<code>查看源码</code>命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。</p></li></ul><h4 id="描述问题应准确且有内容">描述问题应准确且有内容</h4><ul><li>仔细、清楚地描述问题的症状</li><li>描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等）</li><li>描述提问前做过的研究及其理解。</li><li>描述提问前为确定问题而采取的诊断步骤。</li><li>描述最近对计算机或软件配置的任何相关改变。</li><li>如果可能，提供在可控环境下重现问题的方法。</li><li>尽最大努力预测黑客会提到的问题，并提前备好答案。</li></ul><p>如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。</p><p><a href="http://www.chiark.greenend.org.uk/%7Esgtatham/">西蒙.泰瑟姆（Simon Tatham）</a>写过一篇《<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/bugs-tw.html">如何有效报告Bug》</a>的文章，我强烈推荐各位阅读。</p><h4 id="量不在多精炼则灵">量不在多，精炼则灵</h4><p>你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。</p><p>至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 <code>有用的</code> 回复。第三，在提纯Bug报告的过程中，你可能自己就找到了解决办法或权宜之计。</p><h4 id="别急于宣称找到bug">别急于宣称找到Bug</h4><p>当你在一个软件中遇到问题，除非你 非常、非常 的有根据，不要动辄声称找到了Bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“Bug”，你应该能提供相应位置的替代文本。</p><p>记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（<a href="#你在报怨前已经做了这些，是吧%20？">你在报怨前已经做了这些，是吧 ？</a>）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了Bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“Bug”也是特别不老练的。</p><p>提问时，即使你私下非常确信已经发现一个真正的Bug，最好写得象是 你 做错了什么。如果真的有Bug，你会在回复中看到这点。这样做的话，如果真有虫子，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。</p><h4 id="低声下气代替不了做自己的家庭作业">低声下气代替不了做自己的家庭作业</h4><p>有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。</p><p>别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。</p><p>有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。</p><h4 id="描述问题症状而不是猜测">描述问题症状而不是猜测</h4><p>告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。</p><p>愚蠢： &gt;我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？</p><p>明智： &gt; 我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。</p><p>由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。</p><h4 id="按时间先后罗列问题症状">按时间先后罗列问题症状</h4><p>刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。</p><p>如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。</p><p>如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。</p><h4 id="描述目标而不是过程">描述目标而不是过程</h4><p>如果你想弄清楚如何做某事（而不是报告一个Bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。</p><p>经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。</p><p>愚蠢： &gt; 我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？</p><p>明智： &gt; 我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。</p><p>第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。</p><h4 id="别要求私下回复电邮">别要求私下回复电邮</h4><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。</p><p>当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。</p><p>对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。</p><h4 id="提问应明确">提问应明确</h4><p>漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。</p><p>如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。</p><p>要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。</p><p>所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。</p><h4 id="关于代码的问题">关于代码的问题</h4><p>别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示<x>，但实际出现的是<y>”非常有可能让你得到回复。</p><p>最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。</p><p>生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。</p><p>如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h4 id="别张贴家庭作业式问题">别张贴家庭作业式问题</h4><p>黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。</p><h4 id="删除无意义的要求">删除无意义的要求</h4><p>抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。</p><p>一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。</p><h4 id="不要把问题标记为紧急即使对你而言的确如此">不要把问题标记为“紧急”，即使对你而言的确如此</h4><p>这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！</p><p>有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。</p><p>当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。</p><h4 id="礼貌总是有益的">礼貌总是有益的</h4><p>礼貌一点，使用 <code>请</code> 和 <code>谢谢你的关注</code> 或者 <code>谢谢你的关照</code>，让别人明白你感谢他们无偿花时间帮助你。</p><p>坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的Bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的）</p><p>然尔，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。</p><p>（我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 <code>提前谢了</code>，事后 再 对回复者表示感谢，要么换种方式表达，譬如用 <code>谢谢你的关注</code> 或 <code>谢谢你的关照</code>）。</p><h4 id="问题解决后追加一条简要说明">问题解决后追加一条简要说明</h4><p>问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。</p><p>最理想的方式是向最初提问的线索回复此消息，并在主题中包含 <code>已解决</code>、<code>已搞定</code> 或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 <code>问题 X</code> 和 <code>问题 X-已解决</code> 的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。</p><p>追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。</p><p>对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。</p><p>除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。</p><p>最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。<code>挠痒痒</code> 为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。</p><p>考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。</p><h3 id="如何解读回答">如何解读回答</h3><h4 id="读读该死的手册rtfm和搜搜该死的网络stfw如何明白你已完全搞砸">“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸</h4><p>有一个古老而神圣的传统：如果你收到 <code>读读该死的手册</code>（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。</p><p>“读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“<a href="http://lmgtfy.com/">谷歌是你的朋友！</a>”)</p><p>在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。</p><p>通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：</p><ul><li>第一，你要的信息很容易找到。</li><li>第二，自已找要比别人喂到嘴里能学得更多。</li></ul><p>你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。</p><h4 id="如果还不明白">如果还不明白……</h4><p>如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。</p><p>譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？”</p><h4 id="对待无礼">对待无礼</h4><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。）</p><p>在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。</p><h3 id="别象失败者那样反应">别象失败者那样反应</h3><p>在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：</p><p>熬过去，这很正常。事实上，它是有益健康与恰当的。</p><p>社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。</p><p>是夸张的“友谊”（以上述方式）还是有用？挑一个。</p><p>记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。</p><p>这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。</p><h3 id="提问禁忌">提问禁忌</h3><p>下面是些典型的愚蠢问题和黑客不回答它们时的想法。</p><p>问：我到哪可以找到某程序或 X 资源？</p><p>问：我怎样用 X 做 Y？</p><p>问：如何配置我的 shell 提示？</p><p>问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？</p><p>问：我的{程序、配置、SQL 语句}不运行了</p><p>问：我的视窗电脑出问题了，你能帮忙吗？</p><p>问：我的程序不运行了，我认为系统工具X有问题</p><p>问：我安装 Linux 或 X 遇到困难，你能帮忙吗？</p><p>问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？</p><hr /><p>问：<br />&gt; 我到哪可以找到某程序或 X 资源？</p><p>答：<br />&gt; 在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？</p><p>问：<br />&gt; 我怎样用 X 做 Y？</p><p>答：<br />&gt; 如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。</p><p>问：<br />&gt; 如何配置我的 shell 提示？</p><p>答：<br />&gt; 如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。</p><p>问：<br />&gt; 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？</p><p>答：<br />&gt; 试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。</p><p>问：<br />&gt; 我的{程序、配置、SQL 语句}不运行了</p><p>答：<br />&gt; 这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：</p><ul><li>你还有什么补充吗？</li><li>噢，太糟了，希望你能搞定。</li><li>这跟我究竟有什么关系？</li></ul><p>问：<br />&gt; 我的视窗电脑出问题了，你能帮忙吗？</p><p>答：<br />&gt; 是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。</p><p>问：<br />&gt; 我的程序不运行了，我认为系统工具 X 有问题</p><p>答：<br />&gt; 你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。</p><p>问：<br />&gt; 我安装 Linux 或 X 遇到困难，你能帮忙吗？</p><p>答：<br />&gt; 不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表）</p><p>注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。</p><p>问：<br />&gt; 我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？</p><p>答：<br />&gt; 想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。</p><h4 id="好问题与坏问题">好问题与坏问题</h4><p>最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。</p><p>愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？ &gt; 这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。</p><p>明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？ &gt; 这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。</p><p>愚蠢： 我不能编译某项目的源代码，它为什么这么破？ &gt; 提问者假设是别人搞砸了，太自大了。</p><p>明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？ &gt; 提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。</p><p>愚蠢： 我的主板有问题，谁能帮我？ &gt; 某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。</p><p>明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？ &gt; 相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。</p><p>在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。</p><p>事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。</p><p>通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。</p><p>事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。</p><p>黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。</p><h3 id="如果得不到回答">如果得不到回答</h3><p>如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。</p><p>一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。</p><p>有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。</p><p>还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。</p><p>象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。</p><h3 id="如何更好地回答">如何更好地回答</h3><p>态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p>对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。</p><p>如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p>如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。</p><p>探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好</p><p>如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。</p><p>请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过<code>X，Y，Z，A，B 与 C</code> 都没有得到想要的結果，那么回复 <code>试试 A 或 B</code> 或者给出一个内容为 <code>试一下 X，Y，Z，A，B 或 C</code> 的链接将极其无益！</p><p>帮助你的社区从中学习。当回复一个好问题时，问问自己 <code>如何修改相关文件或 FAQ 文档以免再次解答同样的问题？</code>，接着再向文档维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。</p><h3 id="相关资源">相关资源</h3><p>如果需要个人电脑、Unix 和互联网如何工作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 和互联网工作的基本原理</a>。</p><p>当你发布软件或补丁时，试着按 <a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a> 操作。</p><h3 id="鸣谢">鸣谢</h3><p>伊夫林.米切尔（Evelyn Mitchell）贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节，米哈伊尔.罗门迪克（Mikhail Ramendik）贡献了一些特别有价值的建议和改进。</p>]]></content>
    
    
    <categories>
      
      <category>方法论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Web学习</title>
    <link href="/2022/05/06/%E5%90%8E%E7%AB%AF/Java/Java%20Web%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/06/%E5%90%8E%E7%AB%AF/Java/Java%20Web%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="mysql">MySQL</h2><blockquote><p>关系型数据库管理系统</p></blockquote><h3 id="常用命令">常用命令</h3><h4 id="数据库管理命令">数据库管理命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -u&lt;use-name&gt; -p&lt;password&gt;#登陆数据库管理系统<br></code></pre></td></tr></table></figure><h4 id="ddl">DDL</h4><blockquote><p>(Data Definition Language)对数据集合（数据库，表）整体进行操作</p></blockquote><ul><li>对数据库操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#显示数据库<br>show databases<br><br>#创建数据库<br>CREATE DATABASE 数据库名称;<br>CREATE DATABASE db1;<br>CREATE DATABASE IF NOT EXISTS 数据库名称;<br>CREATE DATABASE IF NOT EXISTS db1;<br><br>#删除数据库<br>DROP DATABASE 数据库名称;<br>DROP DATABASE db1;<br>DROP DATABASE IF EXISTS 数据库名称;<br>DROP DATABASE IF EXISTS db1;<br><br>#选择数据库<br>USE 数据库名称;<br>USE db1;<br><br>#查看当前数据库<br>SELECT DATABASE();<br></code></pre></td></tr></table></figure><ul><li>对表操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#显示表<br>SHOW TABLES;<br><br>#查询表结构<br>DESC 表名称;<br><br>#创建表<br>CREATE TABLE 表名 (<br>    字段名1  数据类型1,<br>    字段名2  数据类型2,<br>    …<br>    字段名n  数据类型n<br>);<br><br>#删除表<br>DROP TABLE 表名;<br>DROP TABLE IF EXISTS 表名;<br><br>#修改表名<br>ALTER TABLE 表名 RENAME TO 新的表名;<br><br>#添加列<br>ALTER TABLE 表名 ADD 列名 数据类型;<br><br>#修改数据类型<br>ALTER TABLE 表名 MODIFY 列名 新数据类型;<br><br>#修改列名和数据类型<br>ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;<br><br>#删除列<br>ALTER TABLE 表名 DROP 列名;<br></code></pre></td></tr></table></figure><h4 id="dml">DML</h4><blockquote><p>(Data Manipulation Language)对数据（表中数据）进行增删</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#所有列添加数据<br>INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);<br><br>#制定列添加数据<br>INSERT INTO 表名 VALUES(值1,值2,…);<br><br>#批量添加数据<br>INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;<br>INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;<br><br>e.g.<br>use db1;<br>select * from students;<br>INSERT INTO students VALUES <br>    (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br>    <br>#修改数据(不添加where筛选数据则修改所有数据对应属性)<br>UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;<br><br>e.g. <br>UPDATE students SET 姓名=&#x27;张三&#x27; where 生日=&#x27;1999-11-11&#x27;;<br><br>#删除数据<br>DELETE FROM 表名 [WHERE 条件] ;<br></code></pre></td></tr></table></figure><h4 id="dql">DQL</h4><blockquote><p>(Data Query Language) 对数据（表中数据）进行查询</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>    字段列表<br>FROM <br>    表名列表 <br>WHERE <br>    条件列表<br>GROUP BY<br>    分组字段<br>HAVING<br>    分组后条件<br>ORDER BY<br>    排序字段<br>LIMIT<br>    分页限定<br>    <br>#查询字段([去重复])<br>SELECT [DISTINCT] 字段列表（*） FROM 表名;<br><br>#条件查询<br>SELECT 字段列表 FROM 表名 WHERE 条件列表;<br><br>#排序查询<br>SELECT 字段列表 FROM 表名 WHERE 条件列表 [order by &lt;字段&gt; &lt;desc/asc&gt; , <br>                                &lt;字段&gt; &lt;desc/asc&gt;--第二字段<br>                               ];<br>                               <br>#聚合函数<br>count, max, min, sum, avg<br>SELECT 聚合函数名(列名) FROM 表;--为null时conut不统计，count(*)强制统计所有数据<br><br>#分组查询<br>select sex, avg(math),count(*) from stu where math &gt; 70 group by sex having count(*)  &gt; 2;<br><br>#分页查询<br>SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;<br></code></pre></td></tr></table></figure><img src="/2022/05/06/%E5%90%8E%E7%AB%AF/Java/Java%20Web%E5%AD%A6%E4%B9%A0/img.png" class=""><h4 id="dcl">DCL</h4><blockquote><p>(Data Control Language) 数据库管理系统权限控制</p></blockquote><h3 id="数据类型">数据类型</h3><table><thead><tr class="header"><th style="text-align: center;">数值</th><th style="text-align: center;">日期</th><th style="text-align: center;">字符串</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">tinyint : 小整数型，占一个字节</td><td style="text-align: center;">date ： 日期值。只包含年月日</td><td style="text-align: center;">char ： 定长字符串，e.g. name char(10)</td></tr><tr class="even"><td style="text-align: center;">int ： 大整数类型，占四个字节</td><td style="text-align: center;">datetime ： 混合日期和时间值。包含年月日时分秒</td><td style="text-align: center;">varchar ： 变长字符串，e.g. name archer(10)</td></tr><tr class="odd"><td style="text-align: center;">double ： 浮点类型，使用格式： 字段名 double(总长度,小数点后保留的位数)</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h3 id="数据约束">数据约束</h3><blockquote><p>对数据字段值进行限制</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#约束关键字<br>NOT NULL<br>UNIQUE [AUTO_INCREMENT]<br>PRIMARY KEY<br>CHECK <br>DEFAULT<br>FOREIGN KEY<br><br>#添加约束<br>-- 创建表时添加非空约束<br>CREATE TABLE 表名(<br>   列名 数据类型 NOT NULL,<br>   …<br>); <br>-- 建完表后添加非空约束<br>ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;<br><br>#删除约束<br>ALTER TABLE 表名 MODIFY 字段名 数据类型;<br></code></pre></td></tr></table></figure><h3 id="数据库设计">数据库设计</h3><h4 id="外键">外键</h4><blockquote><p>A表数据中某一字段值和B表中的某个数据的对应关系</p></blockquote><h4 id="表关系">表关系</h4><ul><li>一对一</li><li>一对多</li><li>多对多</li></ul><h4 id="多表查询">多表查询</h4><blockquote><p>对两表数据集合直积产生的数据集合进行筛选查询</p></blockquote><h5 id="连接查询">连接查询</h5><ul><li>内连接查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from &lt;t1&gt;, &lt;t2&gt; where &lt;t1&gt;.&lt;att&gt; = &lt;t2&gt;.&lt;att&gt;<br></code></pre></td></tr></table></figure><ul><li>外连接查询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左外连接<br>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;<br><br>-- 右外连接<br>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;<br></code></pre></td></tr></table></figure><h5 id="子查询">子查询</h5><blockquote><p>嵌套查询</p></blockquote><h4 id="事务">事务</h4><blockquote><p>Transaction，数据库命令脚本，同时类似于原子操作，各个命令整体执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#start开始，commit或rollback结束<br>START TRANSACTION; BEGIN;<br><br>commit; rollback;<br></code></pre></td></tr></table></figure><h2 id="jdbc">JDBC</h2><blockquote><p>Java DataBase Connectivity，Java调用DBMS的API</p><p>Java定义接口，各DBMS对接口进行实现给出实现类</p></blockquote><h2 id="driud">Driud</h2><blockquote><p>数据库连接池，对connection进行复用提升数据库操作效率</p></blockquote><h2 id="maven">Maven</h2><blockquote><p>用于管理和构建Java项目的工具</p></blockquote><h2 id="mybatis">MyBatis</h2><blockquote><p>持久层框架，简化JDBC开发</p><p>对JDBC代码进行封装，实现配置与代码分离</p></blockquote><h2 id="html">HTML</h2><blockquote><p>超文本标记语言</p><p>定义网页内容</p></blockquote><h2 id="css">CSS</h2><blockquote><p>层叠样式表</p><p>定义网页形式</p></blockquote><h2 id="javascript">JavaScript</h2><blockquote><p>浏览器内核执行的脚本语言</p><p>在浏览器端，动态生成网页内容，并可实现简单的表单功能</p></blockquote><h2 id="http">Http</h2><blockquote><p>超文本传输协议</p></blockquote><h2 id="tomcat">Tomcat</h2><blockquote><p>Web服务器程序</p></blockquote><h2 id="servlet">Servlet</h2><blockquote><p>提供具体Web服务</p><p>实现基于Http的业务功能</p></blockquote><h2 id="jsp">JSP</h2><blockquote><p>Java Server Pages</p><p>在服务器端，通过Java动态生成HTML文件</p></blockquote><h2 id="fq">F&amp;Q</h2><ul><li>如何查看MySQL运行端口号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#x27;port&#x27;<br></code></pre></td></tr></table></figure><ul><li>如何查看MySQL配置文件路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql --<span class="hljs-built_in">help</span> | grep my.cnf<br></code></pre></td></tr></table></figure><ul><li>使用Maven报错<code>**Error : java 不支持发行版本5**</code></li></ul><p><a href="https://blog.csdn.net/qq_51263533/article/details/120209830">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP笔记</title>
    <link href="/2022/05/05/%E6%9D%82%E9%A1%B9/CSAPP%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/05/%E6%9D%82%E9%A1%B9/CSAPP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="exceptional-control-flow">Exceptional Control Flow</h2><blockquote><p>Control Flow是即将执行的指令串</p><p>Exceptional Control Flow是顺序被打乱的指令串</p></blockquote><h3 id="exceptions">Exceptions</h3><blockquote><p>Exceptions有四种类型，分别对应不同打乱指令串的方式</p></blockquote><ul><li>Interuption</li></ul><p>异步，即发生与否与正在执行的指令无关</p><ul><li>Trap</li></ul><p>同步。指令主动调用，通常用于系统调用</p><ul><li>Fault</li></ul><p>同步，跳转至处理程序，可能返回原指令串下一条指令或中断程序</p><ul><li>Aborts</li></ul><p>中断程序</p><h3 id="processes">Processes</h3>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>literature</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github学习</title>
    <link href="/2022/05/05/%E6%9D%82%E9%A1%B9/Github%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/05/%E6%9D%82%E9%A1%B9/Github%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="github">Github</h1><blockquote><p>参考链接：<a href="https://www.bilibili.com/video/BV1q54y1f7h6?spm_id_from=333.337.search-card.all.click">B站</a>，<a href="https://github.com/youhuangla/Note/tree/main/web">Gihub笔记</a></p></blockquote><h2 id="高级搜索">高级搜索</h2><p><a href="https://docs.github.com/cn/search-github/getting-started-with-searching-on-github/about-searching-on-github">About searching on GitHub - GitHub Docs</a></p><p><a href="https://docs.github.com/cn/search-github/searching-on-github/searching-code">搜索代码 - GitHub Docs</a></p><h2 id="查找文件">查找文件</h2><ul><li><p><code>t</code>查找文件</p></li><li><p><code>l</code>查找行</p><ul><li>点击行号可复制</li><li><code>b</code>查改更改记录</li></ul></li></ul><h3 id="快捷键">快捷键</h3><blockquote><p><a href="https://docs.github.com/cn/get-started/using-github/keyboard-shortcuts">键盘快捷键 - GitHub Docs</a></p></blockquote><img src="/2022/05/05/%E6%9D%82%E9%A1%B9/Github%E5%AD%A6%E4%B9%A0/gs-1710410.png" class=""><h2 id="在线代码编辑">在线代码编辑</h2><ul><li><code>.</code>在线运行VSCode</li><li>在项目地址前加上<code>gitpod.io/#/</code>前缀，可在线执行代码</li></ul><h2 id="项目推送">项目推送</h2>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2022/05/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="排序算法">排序算法</h2><h3 id="冒泡排序">冒泡排序</h3><img src="/2022/05/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/image-29.png" class=""><h3 id="选择排序">选择排序</h3><img src="/2022/05/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/image-30.png" class=""><h2 id="查找算法">查找算法</h2><h3 id="二分查找">二分查找</h3><img src="/2022/05/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/image-31.png" class=""><img src="/2022/05/04/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/image-32.png" class="">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA学习</title>
    <link href="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/IDEA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/03/%E5%90%8E%E7%AB%AF/Java/IDEA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="idea项目结构">IDEA项目结构</h2><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/IDEA%E5%AD%A6%E4%B9%A0/image-3.png" class=""><h2 id="快捷键">快捷键</h2><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/IDEA%E5%AD%A6%E4%B9%A0/image-7.png" class=""><h2 id="debug">Debug</h2><p><a href="https://www.bilibili.com/video/BV1xa411Y72S?spm_id_from=333.851.b_7265636f6d6d656e64.1">Debug技巧</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE学习</title>
    <link href="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="java-se学习">Java SE学习</h1><blockquote><p>Java SE中的SE为Standard Edition的首字母缩写</p><p>参考资料：<a href="https://nxgdfhczg0.feishu.cn/drive/folder/fldcnhbDPwIhTzzB6R6tT6PfLvb">志哥的笔记</a>， <a href="https://www.geeksforgeeks.org/java/?ref=shm">GeeksforGeeks</a></p></blockquote><h2 id="数据类型">数据类型</h2><blockquote><p>Java是一种静态语言，即所有变量和表达式类型均在编译时可知的一门编程语言</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/Data-types-in-Java-1552872.jpg" class=""><h3 id="基础数据类型">基础数据类型</h3><blockquote><p>值得注意的是，char类型统一使用unicode编码，并占用两字节内存</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/Primitive-Data-Types-in-Java-4.jpg" class=""><h3 id="对象数据类型">对象数据类型</h3><blockquote><p>又称为Non-primative Data Type或Reference Data Type或Object Data type</p><p>Java中没有指针概念，所有动态生成对象使用的堆空间，均通过Java垃圾回收机制回收</p><p>在我理解看来，所谓对象数据类型，即为赋值操作时（包括函数传参）不会对数据类型代表的原始数据进行拷贝操作的数据类型</p></blockquote><h4 id="string">String</h4><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image.png" class=""><h4 id="enum">enum</h4><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-4.png" class=""><h4 id="arraylist">ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index,E element)</span>;<br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-2.png" class=""><h4 id="array">Array</h4><ul><li>Java中所有数组都是动态生成的（和C++不同）</li><li>可通过length属性获取数组长度</li><li>可嵌套使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[][] b = &#123;a, a, a, a&#125;;<br></code></pre></td></tr></table></figure><ul><li>数组下标从0开始</li><li>可用于static field, local variable, method parameter</li><li>superclass是Object</li><li>实现了接口<code>Cloneable</code>和<code>Java.io.Serializable</code></li></ul><h4 id="object">Object</h4><ul><li>Class</li></ul><blockquote><p>Object数据类型需要依照原型来创建，Class正是Object创建时参考的原型</p></blockquote><ul><li>Behavior</li></ul><blockquote><p>程序的任务之一便是对数据的处理，因此自定义的数据类型同样需要定义可以对该数据类型进行的操作</p></blockquote><ul><li>State</li></ul><blockquote><p>每一个数据类型都有代表其数据类型的属性，这些属性的数值可以表征一个实例的状态</p></blockquote><h2 id="面向对象编程技术">面向对象编程技术</h2><h3 id="关键字">关键字</h3><h4 id="public">public</h4><blockquote><p>修饰方法</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-3.png" class=""><h4 id="final">final</h4><ul><li>对类：禁止继承</li><li>对方法：禁止重写</li><li>对变量：禁止二次赋值</li></ul><h4 id="abstract">abstract</h4><blockquote><p>被abstract修饰的类称为抽象类，无法实例化。</p></blockquote><h4 id="interface">interface</h4><blockquote><p>接口，相较于abstract更为抽象</p></blockquote><ul><li>对方法的修饰符<ul><li>public（缺省）：必须实现</li><li>default：</li><li>static：必须用借口名调用</li><li>private：只能被本类中其他方法调用</li></ul></li></ul><h4 id="static">static</h4><ul><li>修饰属性与方法</li></ul><blockquote><p>所有实例共用，建议通过类名调用</p></blockquote><ul><li>修饰代码块</li></ul><blockquote><p>称为静态代码段，类加载时执行，初始化类属性</p></blockquote><ul><li>应用实例</li></ul><blockquote><p>单例模式</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-5.png" class=""><h4 id="常量">常量</h4><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-6.png" class=""><h3 id="继承">继承</h3><blockquote><p>一种代码复用技巧</p></blockquote><ul><li>使用<code>@Override</code>检测重载是否正确</li><li>方法和属性的调用均采用就近查找</li><li>不支持多重继承</li></ul><h3 id="多态">多态</h3><blockquote><p>动态分配实例调用方法时所指代码段</p></blockquote><ul><li>判断实例类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">&lt;variable-name&gt; instance of &lt;class-name&gt;<br></code></pre></td></tr></table></figure><h3 id="匿名类">匿名类</h3><blockquote><p>不需要使用类名即可直接实例化，通常继承抽象类或者接口</p><p>可用于函数参数中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Polygon</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;在 Polygon 类内部&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createClass</span><span class="hljs-params">()</span> &#123;<br><br>      <span class="hljs-comment">// 创建的匿名类继承了 Polygon 类</span><br>      <span class="hljs-type">Polygon</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Polygon</span>() &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;在匿名类内部。&quot;</span>);<br>         &#125;<br>      &#125;;<br>      p1.display();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用类">常用类</h2><h3 id="io相关类">IO相关类</h3><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-2-1817433.png" class=""><h3 id="系统相关类">系统相关类</h3><h4 id="scanner">Scanner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> sc.nextInt();<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></table></figure><h4 id="system">System</h4><blockquote><p>系统相关的工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">currentTimeMillis</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数)</span>;<br></code></pre></td></tr></table></figure><h3 id="数学相关类">数学相关类</h3><h4 id="random">Random</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> r.nextInt(<span class="hljs-number">100</span>);<span class="hljs-comment">//左闭右开</span><br><br></code></pre></td></tr></table></figure><h4 id="math">Math</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">ceil</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">floor</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">round</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">random</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="bigdecimal">BigDecimal</h4><blockquote><p>科学计算</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigDecimal <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">double</span> val)</span>;<br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">add</span><span class="hljs-params">(BigDecimal b)</span>;<br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">subtract</span><span class="hljs-params">(BigDecimal b)</span>;<br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">multiply</span><span class="hljs-params">(BigDecimal b)</span>;<br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">divide</span><span class="hljs-params">(BigDecimal b)</span>;<br><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">divide</span> <span class="hljs-params">(另一个BigDecimal对象，精确几位，舍入模式)</span> ;<br></code></pre></td></tr></table></figure><h3 id="字符串相关类">字符串相关类</h3><h4 id="stringbuilder">StringBuilder</h4><blockquote><p>可变的字符串类，改善String操作效率。</p><p>因为String在Java中是不可操作的，每次对String类型进行+-操作都会新建整个字符串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">(String str)</span>;<br><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(任意类型)</span>;<br><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">reverse</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="正则表达式">正则表达式</h4><blockquote><p>格式化匹配字符</p></blockquote><h5 id="matches">matches</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(String regex)</span>;<br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-17.png" class=""><blockquote><p>字符类，匹配一个字符</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-18.png" class=""><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-19.png" class=""><blockquote><p>预定义字符类，默认匹配一个字符</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-20.png" class=""><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-21.png" class=""><blockquote><p>匹配多个字符</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-22.png" class=""><ul><li>案例1：请编写程序模拟用户输入手机号码、验证格式正确，并给出提示，直到格式输入正确为止</li></ul><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-23.png" class=""><ul><li>案例2：请编写程序模拟用户输入邮箱号码、验证格式正确，并给出提示，直到格式输入正确为止</li></ul><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-24.png" class=""><ul><li>案例3：请编写程序模拟用户输入电话号码、验证格式正确，并给出提示，直到格式输入正确为止</li></ul><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-25.png" class=""><h5 id="replacesplit">replace/split</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按照正则表达式匹配的内容进行替换</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(String regex,String newStr)</span>;<br><span class="hljs-comment">//按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</span><br><span class="hljs-keyword">public</span> String[] split(String regex);<br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-26.png" class=""><h5 id="爬取信息">爬取信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;&quot;</span> +<span class="hljs-comment">//邮箱</span><br>  <span class="hljs-string">&quot;|1[3-0]\\d&#123;9&#125;&quot;</span> +<span class="hljs-comment">//手机号码</span><br>  <span class="hljs-string">&quot;|(0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;)|(400-?\\d&#123;3,9&#125;-?\\d&#123;3,9&#125;)&quot;</span><span class="hljs-comment">//电话号码</span><br><span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">mathcer</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br><span class="hljs-keyword">while</span>(matcher.find())&#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> matcher.group();<br>  System.out.println(rs1);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-27.png" class=""><h3 id="object-1">Object</h3><blockquote><p>根本类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<span class="hljs-comment">//返回对象在堆中地址---类的全限名@内存地址，重写以返回子类信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>; <span class="hljs-comment">//判断两个实例地址是否相同</span><br></code></pre></td></tr></table></figure><h3 id="objects">Objects</h3><blockquote><p>工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNull</span><span class="hljs-params">(Object obj)</span>;<br></code></pre></td></tr></table></figure><h3 id="时间相关类">时间相关类</h3><h4 id="data">Data</h4><blockquote><p>系统日期</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">()</span>; <span class="hljs-comment">//此刻时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Date</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span>;<span class="hljs-comment">//time单位为毫秒</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span>;<span class="hljs-comment">//返回从1970年1月1日00:00:00走到此刻的总的毫秒数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTime</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span>;<span class="hljs-comment">//设置日期对象的时间为当前时间毫秒值对应的时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Date when)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">after</span><span class="hljs-params">(Date when)</span>;<br></code></pre></td></tr></table></figure><h4 id="simpledateformat">SimpleDateFormat</h4><blockquote><p>实现日期时间格式化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleDateFormat</span><span class="hljs-params">(String pattern)</span>;<br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-9.png" class=""><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-10.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Date date)</span>;<span class="hljs-comment">//将日期格式化成日期/时间字符串</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">format</span><span class="hljs-params">(Object time)</span>;<span class="hljs-comment">//将时间毫秒值式化成日期/时间字符串</span><br><span class="hljs-keyword">public</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String source)</span>;<span class="hljs-comment">//从给定字符串的开始解析文本以生成日期</span><br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-11.png" class=""><h4 id="calendar">Calendar</h4><blockquote><p>抽象类</p><p>代表了系统此刻日期对应的日历对象</p><p>可变日期对象</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>;<span class="hljs-comment">//获取当前日历对象</span><br><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>system.out.println(cal);<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> field)</span><br></code></pre></td></tr></table></figure></p><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-12-1631919.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> field,<span class="hljs-type">int</span> value)</span>;<span class="hljs-comment">//修改日历的某个字段信息。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> field,<span class="hljs-type">int</span> amount)</span>;<span class="hljs-comment">//为某个字段增加/减少指定的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Date <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span>;<span class="hljs-comment">//拿到此刻日期对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTimeInMillis</span><span class="hljs-params">()</span>;<span class="hljs-comment">//拿到此刻时间毫秒值</span><br></code></pre></td></tr></table></figure><h4 id="localtime-localdate-localdatetime">LocalTime /LocalDate / LocalDateTime</h4><blockquote><p>不变数据类型，类似于String</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-13.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Xxxx <span class="hljs-title function_">now</span><span class="hljs-params">()</span>;<span class="hljs-comment">//根据当前时间创建对象</span><br><br><span class="hljs-type">LocaDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now();<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">llocalTime</span> <span class="hljs-operator">=</span> LocalTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Xxxx <span class="hljs-title function_">of</span><span class="hljs-params">(…)</span>;<span class="hljs-comment">//指定日期/时间创建对象</span><br><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2099</span> , <span class="hljs-number">11</span>,<span class="hljs-number">11</span>);<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">localTime1</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime1</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">13</span>, <span class="hljs-number">23</span>, <span class="hljs-number">43</span>);<br><br><span class="hljs-comment">//获取字段</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">geYear</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMonthValue</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDayOfMonth</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDayOfYear</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> DayOfWeek <span class="hljs-title function_">getDayOfWeek</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//转换API</span><br><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title function_">toLocalDate</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> LocalTime <span class="hljs-title function_">toLocalTime</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//修改API</span><br>plusDays, plusWeeks, plusMonths, plusYears<br>minusDays, minusWeeks, minusMonths, minusYears<br>withDayOfMonth, withDayOfYear, withMonth, withYear<br>isBefore, isAfter<br></code></pre></td></tr></table></figure><h4 id="instant">Instant</h4><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-14.png" class=""><h4 id="datatimeformatter">DataTimeFormatter</h4><blockquote><p>在JDK8中，引入了一个全新的日期与时间格式器DateTimeFormatter</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-36.png" class=""><h4 id="durationperiod">Duration/Period</h4><blockquote><p>日期间隔差异</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-37.png" class=""><blockquote><p>时间间隔差异</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-38.png" class=""><h4 id="chronounit">ChronoUnit</h4><blockquote><p>ChronoUnit类可用于在单个时间单位内测量一段时间，这个工具类是最全的了，可以用于比较所有的时间单位</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-39.png" class=""><h3 id="数据结构相关类">数据结构相关类</h3><h4 id="集合类">集合类</h4><blockquote><p>不仅充当容器，而且不同容器可以充分代表不同容器内各种数据的关系</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-2-1651503.png" class=""><h5 id="collection">Collection</h5><blockquote><p>存储数据</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-1651493.png" class=""><ul><li>常用API</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">add;clear;remove;<br>contains;isEmpty;<br>size;toArray;addAll;<br></code></pre></td></tr></table></figure><ul><li><p>遍历方法</p><ul><li>迭代器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Iterator&lt;String&gt; it = lists.iterator();<br><br><span class="hljs-comment">//询问当前位置是否有元素存在，存在返回true ,不存在返回false</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">//获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。</span><br><span class="hljs-comment">//迭代器如果取元素越界会出现NoSuchElementException异常</span><br>E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> it.next();<br>  System.out.println(ele);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>foreach语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arrs)&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>lambada语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lists.forEach(System.out.println);<br></code></pre></td></tr></table></figure></li><li><p>删除</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代器中使用</span><br>it.remove();<br></code></pre></td></tr></table></figure><h6 id="list">List</h6><blockquote><p>有序，可重复，有索引</p></blockquote><ul><li>独有API</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">add; remove; set; get;<br></code></pre></td></tr></table></figure><ul><li><p>两种数据结构</p><ul><li><p>ArrayList</p><blockquote><p>连续内存空间，当内从空间不够时开辟大空间</p></blockquote></li><li><p>LinkedList</p><blockquote><p>双向链表</p></blockquote><ul><li>独有API</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">addFirst;addLast;<br>getFirst; getLast;<br>removeFirst;removeLast;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="set">Set</h6><blockquote><p>无序，不重复，无索引</p></blockquote><ul><li><p>HashSet</p><blockquote><p>无序，不重复，无索引</p></blockquote><ul><li>底层采用哈希表</li><li>实例对象存储时需要重写方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据对象属性值生成哈希值</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> Objects.hash(age,sex);<br>&#125;<br><br><br><span class="hljs-comment">//根据对象属性值进一步判断对象是否重复</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>==obj)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span>(obj==<span class="hljs-literal">null</span> ||<span class="hljs-built_in">this</span>.getClass()!=obj.getClass())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  Student stu=(Student) obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age==stu.age &amp;&amp; <span class="hljs-built_in">this</span>.sex==stu.sex;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>LinkedHashSet</p><blockquote><p>有序，不重复，无索引</p></blockquote></li><li><p>TreeSet</p><blockquote><p>可排序，不重复，无索引</p></blockquote></li></ul><h5 id="collections">Collections</h5><blockquote><p>集合工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给集合对象批量添加元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> T&gt; c, T... elements)</span>;<br><br><span class="hljs-comment">//打乱List集合元素的顺序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(List&lt;?&gt; list)</span>;<br><br><span class="hljs-comment">//将集合中元素按照默认规则排序</span><br><span class="hljs-comment">//注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list，Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span><br></code></pre></td></tr></table></figure><h5 id="map待补充">Map（待补充）</h5><h3 id="包装类">包装类</h3><blockquote><p>Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型</p><p>集合和泛型其实只能支持包装类型，不支持基本数据类型</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-15.png" class=""><ul><li><p>自动装箱：基本类型的数据和变量可以直接赋值给包装类型的变量</p></li><li><p>自动拆箱：包装类型的变量可以直接赋值给基本数据类型的变量</p></li><li><p>特别之处</p><ul><li>包装类的变量的默认值可以是null，容错率更高</li><li>可以把基本类型的数据转换成字符串类型</li><li>可以把字符串类型的数值转换成真实的数据类型</li></ul><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-16.png" class=""></li></ul><h3 id="arrays">Arrays</h3><blockquote><p>数组操作工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(类型[] a)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(类型[] a)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(类型[] a, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> key)</span>;<br></code></pre></td></tr></table></figure><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-28.png" class=""><h2 id="语法">语法</h2><h3 id="lambda表达式">Lambda表达式</h3><blockquote><p>简化函数式接口匿名类代码写法</p></blockquote><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-33.png" class=""><ul><li><p>函数式接口</p><ul><li>必须是接口</li><li>接口中只有一个抽象方法啊</li><li>函数式接口上有<code>@FunctionalInterface</code>注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimming</span>&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Swimming s)</span>&#123;<br>  s.swim();<br>&#125;<br><br>Swimming s1=()-&gt;System.out.println(<span class="hljs-string">&quot;gogogo&quot;</span>);<br>go(s1);<br></code></pre></td></tr></table></figure></li><li><p>实例</p></li></ul><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-34.png" class=""><img src="/2022/05/03/%E5%90%8E%E7%AB%AF/Java/Java%20SE%E5%AD%A6%E4%B9%A0/image-35.png" class=""><ul><li>省略规则<ul><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时()也可以省略</li><li>如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写,同时要省略分号</li><li>如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。此时，如果这行代码是return语句，必须省略return不写，同时也必须省略";"不写</li></ul></li></ul><h3 id="泛型">泛型</h3><h4 id="修饰类">修饰类</h4><h4 id="修饰方法">修饰方法</h4><h4 id="修饰接口">修饰接口</h4><h2 id="文件引用关系">文件引用关系</h2><ul><li>一个Java文件中可以定义多个类，但是只能有一个类是用public修饰的，public修饰的类名必须成为Java代码的文件名称（建议一个文件只建立一个类）</li><li>同一个包下的类可以互相访问，不同包下的类，必须导包才可以访问：import com....</li><li>同一个类中可以使用多个同名的类，但是默认只能导入一个，其他用包名.类名</li></ul><h2 id="框架">框架</h2><h3 id="logback">Logback</h3><blockquote><p>日志框架</p></blockquote><h3 id="junit">Junit</h3><blockquote><p>单元测试框架</p></blockquote><h3 id="dom4j">dom4j</h3><blockquote><p>xml解析框架</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏清单</title>
    <link href="/2022/05/02/%E6%B8%85%E5%8D%95/%E6%B8%B8%E6%88%8F%E6%B8%85%E5%8D%95/"/>
    <url>/2022/05/02/%E6%B8%85%E5%8D%95/%E6%B8%B8%E6%88%8F%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="类型">类型</h2><h3 id="经营模拟">经营模拟</h3><ul><li>牧场物语</li><li>星露谷物语</li></ul><h3 id="剧情体验">剧情体验</h3><ul><li>寒蝉鸣泣之时</li><li>Clannad</li><li>Summer Pocket</li><li>逆转裁判</li><li>幽灵诡计</li><li>奇异人生</li><li>To the Moon系列</li></ul><h3 id="横版动作">横版动作</h3><ul><li>空洞骑士</li><li>死亡细胞</li><li>武士零</li></ul><h3 id="开放世界">开放世界</h3><ul><li>塞尔达传说：荒野之息</li><li>GTA</li></ul><h3 id="策略规划">策略规划</h3><ul><li><p>文明</p></li><li><p>群星</p></li><li><p>火焰纹章：风花雪月</p></li><li><p>八方旅人</p></li></ul><h3 id="宝可梦">宝可梦</h3><ul><li>火红·叶绿</li><li>红宝石·蓝宝石</li><li>珍珠·钻石</li><li>剑·盾</li><li>阿尔宙斯</li></ul>]]></content>
    
    
    <categories>
      
      <category>清单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>entertainment</tag>
      
      <tag>list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电影清单</title>
    <link href="/2022/05/01/%E6%B8%85%E5%8D%95/%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/"/>
    <url>/2022/05/01/%E6%B8%85%E5%8D%95/%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="未分类">未分类</h2><ul><li>本杰明巴顿奇事</li><li>杀人回忆</li><li>电锯惊魂</li><li>达拉斯买家俱乐部</li><li>雨人</li><li>人工智能</li><li>树大招风</li><li>巴斯特斯克鲁斯的歌谣</li><li>江湖儿女</li><li>刺客聂隐娘</li><li>破风</li><li>阳光下的罪恶</li><li>超脱</li><li>上帝之城</li><li>记忆碎片</li><li>彗星来的那一夜</li><li>恐怖游轮</li><li>牯岭街少年杀人事件</li><li>犬之岛</li></ul><h2 id="情感类型">情感类型</h2><h3 id="欢乐">欢乐</h3><ul><li>侏罗纪公园</li></ul><h3 id="治愈">治愈</h3><ul><li>情书</li><li>海街日记</li><li>机器人总动员</li></ul><h3 id="惊悚">惊悚</h3><ul><li>惊魂记</li></ul><h3 id="思索">思索</h3><ul><li>影子武士</li><li>七武士</li><li>罗生门</li><li>发条橙</li><li>卧虎藏龙</li><li>梦之安魂曲</li><li>辛德勒的名单</li><li>现代启示录</li><li>爱情短片</li><li>索拉里斯</li><li>寄生虫</li><li>这个杀手不太冷</li></ul><h2 id="导演">导演</h2><h3 id="安德烈塔科夫斯基">安德烈塔科夫斯基</h3><ul><li>乡愁</li><li>镜子</li><li>索拉里斯</li></ul><h3 id="黑泽明">黑泽明</h3><ul><li>罗生门</li><li>用心棒</li><li>影子武士</li><li>七武士</li></ul><h3 id="是枝裕和">是枝裕和</h3><ul><li>如父如子</li><li>无人知晓</li><li>步履不停</li><li>奇迹</li><li>海街日记</li></ul><h3 id="莱昂内">莱昂内</h3><ul><li>镖客三部曲</li><li>美国往事</li></ul><h3 id="库布里克">库布里克</h3><ul><li>2001太空漫游</li><li>洛丽塔</li><li>发条橙</li></ul><h3 id="马特达蒙">马特达蒙</h3><ul><li>谍影重重</li></ul><h3 id="维伦纽瓦">维伦纽瓦</h3><ul><li>边境杀手</li></ul><h3 id="李安">李安</h3><ul><li>断背山</li><li>比利林恩的中场战事</li><li>少年派的奇幻漂流</li><li>饮食男女</li><li>色戒</li><li>卧虎藏龙</li></ul><h3 id="王家卫">王家卫</h3><ul><li>阿飞正传</li><li>旺角卡门</li><li>重庆森林</li></ul><h3 id="大卫芬奇">大卫芬奇</h3><ul><li>社交网络</li><li>搏击俱乐部</li><li>十二宫</li><li>七宗罪</li></ul><h3 id="达伦阿伦纳夫斯基">达伦阿伦纳夫斯基</h3><ul><li>梦之安魂曲</li><li>黑天鹅</li><li>圆周率</li><li>摔跤王</li><li>真爱泉源</li></ul><h3 id="希区柯克">希区柯克</h3><blockquote><p>惊悚片祖师爷，我们可以看到很多现代惊悚片都致敬了希区柯克的作品。</p></blockquote><ul><li>电话谋杀案</li><li>惊魂记</li><li>西北偏北</li></ul><h3 id="奥赛佩托纳多雷">奥赛佩托纳多雷</h3><blockquote><p>代表作是时光三部曲，因为太有名了，所以被动的了解了三部电影的全部剧情，因此并没有看过原片（还不快去看？！）</p></blockquote><ul><li>海上钢琴师</li><li>天堂电影院</li><li>西西里的美丽传说</li></ul><h3 id="宫崎骏">宫崎骏</h3><blockquote><p>日本动画大师。</p></blockquote><ul><li>千与千寻</li><li>龙猫</li><li>天空之城</li></ul><h3 id="斯皮尔伯格">斯皮尔伯格</h3><ul><li>拯救大兵瑞恩</li><li>猫鼠游戏</li><li>侏罗纪公园</li><li>辛德勒名单</li></ul><h3 id="大卫林奇">大卫·林奇</h3><ul><li>穆赫兰道</li><li>象人</li></ul><h3 id="李俊益">李俊益</h3><ul><li>素媛</li><li>思悼</li></ul><h3 id="弗朗西斯福特科波拉">弗朗西斯·福特·科波拉</h3><ul><li>教父</li><li>现代启示录</li></ul><h3 id="奥逊威尔斯">奥逊威尔斯</h3><blockquote><p>如果电影行业有天才的话，那他就是了。还有什么人能集导演、编剧、制片人、演员于一身呢？</p></blockquote><ul><li>公民凯恩</li><li>奥罗塞</li></ul><h3 id="基耶斯洛夫斯基">基耶斯洛夫斯基</h3><ul><li>十诫</li><li>杀人短片</li><li>蓝白红</li><li>爱情短片</li></ul>]]></content>
    
    
    <categories>
      
      <category>清单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>entertainment</tag>
      
      <tag>list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>效率工具</title>
    <link href="/2022/05/01/%E6%B8%85%E5%8D%95/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/05/01/%E6%B8%85%E5%8D%95/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>工欲善其事，必先利其器。</p></blockquote><h2 id="文字工作">文字工作</h2><h3 id="typora">Typora</h3><p>非常出色的Markdown编辑器，无论是编辑文本、渲染排版还是格式导出(word, pdf等)都令人满意。</p><h3 id="texpad">Texpad</h3><p>LaTeX编辑器，具备即时渲染功能。</p><h3 id="mindnode">MindNode</h3><p>思维导图软件。</p><h3 id="visual-studio-code">Visual Studio Code</h3><p>文本编辑软件，同时具备许多实用的插件，对代码编写者友好。</p><h3 id="sublime-text">Sublime Text</h3><p>文本编辑软件，界面看上去十分整洁美观。</p><h3 id="reeder">Reeder</h3><p>RSS阅读器，RSS是一种反媒体资讯垄断的资讯获取方式。通过不同平台资讯的对比阅读，可以使我们更加客观全面地了解这个世界正在发生的事情。</p><h3 id="zotero">Zotero</h3><p>文献管理软件，另一款相同类型的软件是Endnote。</p><h2 id="电脑办公">电脑办公</h2><h3 id="alfred">Alfred</h3><p>快捷的操作与丰富强大的自定义功能，极大的简化了常规处理流程，以下是几个例子：</p><blockquote><p>使用command+space快捷键调出命令输入框，可自行配置快捷键</p></blockquote><ul><li><code>网站缩写</code>+ <code>检索关键词</code>，可以在不同网站上进行索引。e.g. <code>bl 新宝岛</code> <code>bing 新宝岛</code> <code>zh 新宝岛</code></li><li><code>df</code>+ <code>单词</code>，可以直接对陌生词汇进行释义查找</li><li><code>应用名称</code>，可以直接打开对应应用</li><li>Clipboard History, 功能如名称所示，可以记录复制内容</li><li>简单的计算器</li><li>Workflows, 通过便携apple提供的脚本编写自动化程序，功能十分强大</li><li>Snippets, 文本替代功能，输入一小段字符即可替代一大段字符，常用于格式化文本的便捷输入</li><li>许多其他功能......</li></ul><h3 id="dark-reader">Dark Reader</h3><p>可以对浏览器网页进行暗色调渲染，夜间浏览网页保护眼睛。</p><h3 id="downie">Downie</h3><p>在各个网站上观看视频时想要下载视频？使用Downie吧。如果你妈想让你给她下载广场舞，这个软件会帮助你解决麻烦。</p><h3 id="iina">IINA</h3><p>Mac上最杰出的视频播放器。</p><h3 id="pdf-expert">PDF Expert</h3><p>PDF阅读器。</p><h2 id="程序效率">程序效率</h2><h3 id="iterm">iTerm</h3><p>Mac上非常出色的终端程序。</p><h3 id="warp">Warp</h3><p>功能十分强大的现代终端程序</p><h2 id="实用网站">实用网站</h2><h3 id="电子书下载网站">电子书下载网站</h3><ul><li><a href="https://www.bookzz.ren">Bookszz</a></li><li><a href="https://www.gutenberg.org">Free eBooks</a></li></ul><h3 id="新闻网站">新闻网站</h3><h3 id="资源网站">资源网站</h3><ul><li><a href="http://bt.neu6.edu.cn/forum.php">六维空间</a>：东北大学pt站，主要用于下载电影</li><li><a href="https://appstorrent.ru/programs/">appstorrents</a>：Mac破解软件网站</li><li><a href="https://ca.bitznet.app/#/register">bitnets</a>：科学上网</li></ul><h3 id="学习网站">学习网站</h3><ul><li><a href="https://www.w3schools.com">w3schools</a>：鼎鼎大名的计算机学习网站</li><li><a href="https://www.geeksforgeeks.org">geeksforgeeks</a>：计算机知识学习网站</li><li><a href="https://salttiger.com">SaltTiger</a>：每天一本计算机书籍</li></ul><h3 id="工具网站">工具网站</h3><ul><li><a href="https://www.latexlive.com/home">latelive</a>：识别图片中公式，并生成LaTeX格式公式</li></ul>]]></content>
    
    
    <categories>
      
      <category>清单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>list</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读清单</title>
    <link href="/2022/05/01/%E6%B8%85%E5%8D%95/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"/>
    <url>/2022/05/01/%E6%B8%85%E5%8D%95/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h3 id="未分类">未分类</h3><ul><li>立体纸雕书:我等你</li><li>她们的传奇</li><li>美术馆全知道</li><li>奥斯维辛</li><li>杀死一只知更鸟</li><li>房思琪的初恋乐园</li><li>天朝的崩溃</li><li>娱乐至死</li><li>走出唯一真理观</li><li>教堂尖塔</li><li>如何阅读一本书</li><li>从卢梭到尼采</li><li>论自由</li><li>功利主义</li><li>哲学的故事</li><li>瘟疫与人</li><li>思想录</li><li>这是不是个人</li><li>沉默</li><li>红字</li><li>人生不设限</li><li>娱乐至死</li><li>乌合之众</li><li>蝇王</li><li>美国宪政历程</li><li>保守主义</li><li>杀死一只知更鸟</li><li>民族认同</li><li>民族主义</li><li>监狱琐记</li><li>终极之问</li><li>四种爱</li><li>德兰修女传</li><li>化身博士</li><li>夜</li><li>旧制度与大革命</li><li>布达佩斯往事</li><li>天堂沉默了半小时</li><li>我有平安如江河</li><li>青灯</li><li>沉默的大多数</li><li>袁氏当国</li><li>朱元璋传</li><li>马丁路德·金自传</li><li>法律创世记</li><li>批评官员的尺度</li><li>林达作品集（全九册)</li><li>通往奴役之路</li><li>新教伦理与资本主义精神</li><li>追寻现代中国</li><li>太平天国</li><li>停滞的帝国</li><li>统一与分裂</li><li>寻找家园</li><li>叫魂</li><li>刘氏女</li><li>日瓦戈医生</li><li>自由及其背叛</li><li>知识分子的鸦片</li><li>古拉格之恋</li><li>科雷马故事</li><li>天朝的崩溃</li><li>知识分子</li><li>白鲸</li><li>艾希曼在耶路撒冷</li><li>路西法效应</li><li>瘟疫与人</li><li>冰点</li><li>人性七论</li><li>耳语者</li><li>奥斯维辛</li><li>返璞归真</li><li>弯曲的脊梁</li><li>公正</li><li>复活</li><li>巨流河</li><li>万历十五年</li><li>当代中国政府与政治</li><li>飞鸟集</li><li>叶赛宁</li><li>人性论</li><li>围城</li><li>政治思考</li><li>好人宋没用</li><li>舌尖上的历史</li><li>小王子</li><li>悲惨世界</li><li>艾略特</li><li>美丽剪辑</li><li>眨眼之间</li><li>剪辑之道</li></ul><h3 id="轻松阅读">轻松阅读</h3><ul><li>假装的艺术</li><li>让别人无法拒绝你</li><li>厨房里的哲学家</li><li>中国居民膳食指南</li><li>结构是什么</li><li>设计中的设计</li></ul><h3 id="社会学读物">社会学读物</h3><ul><li>虐恋亚文化</li><li>同性恋亚文化</li></ul><h3 id="心理学读物">心理学读物</h3><ul><li>亲密关系</li><li>自卑与超越</li></ul><h2 id="作者">作者</h2><h3 id="乔斯坦贾德">乔斯坦·贾德</h3><ul><li>苏菲的世界</li></ul><h3 id="莫言">莫言</h3><ul><li>酒国</li></ul><h3 id="余华">余华</h3><blockquote><p>曾看到评论说余华的写作是”普通人写作能达到的巅峰水准“，诚然，余华写的文字朴实无华，也没有炫技般的技法，但余华那颗对苦难的悲悯之心却是普通人无法拥有的。</p></blockquote><ul><li>在细雨中呼喊</li><li>活着</li></ul><h3 id="毛姆">毛姆</h3><ul><li>毛姆读书随笔</li><li>月亮与六便士</li></ul><h3 id="加缪">加缪</h3><ul><li>西西弗神话</li><li>鼠疫</li><li>局外人</li></ul><h3 id="陀思妥耶夫斯基">陀思妥耶夫斯基</h3><blockquote><p>什么是文学天才？陀思妥耶夫斯基就是文学天才。陀的个人经历坎坷，年轻时参与反沙皇革命活动，被当局命令处死，而就在即将被处死时，又被赦免，流放西伯利亚，在和罪犯一同生活几年后得到释放，继续他的写作生涯，即便是经历了死里逃生，陀个人的苦难经历也并没有结束，赌博时常缠绕着他，赌博带来的破产使他生活贫苦艰难，直至死亡。阅读陀思妥耶夫斯基大段大段的文字时常令人毛骨悚然，尤其是人物矛盾混乱的内心独白或人物对话，让人不禁怀疑，作者是否亲身经历过这些痛苦，并经过深沉的思索和反复的怀疑，最终通过鞭辟入里的文字，将自己内心最混乱不安的灵魂倾诉出来。总而言之，与其期望从我苍白无力的描述中了解陀，不如亲自拿起一本陀的书，然后接受这狂风暴雨般的文字，在这种洗礼下承认陀的伟大。</p></blockquote><ul><li>罪与罚</li><li>地下室手记</li><li>白痴</li><li>群魔</li><li>卡拉马佐夫兄弟</li><li>少年</li><li>被伤害与侮辱的人们</li><li>白夜</li></ul><h3 id="谷崎润一郎">谷崎润一郎</h3><blockquote><p>谷崎润一郎擅长描写阴翳------一种源自人心的阴暗。他对虐恋的描写入木三分，在他这里，没有常规意义下的道德拘束，只有在人性拷问下的放纵快感。</p></blockquote><ul><li>阴翳礼赞</li><li>春琴抄</li></ul><h3 id="川端康成">川端康成</h3><ul><li>古都</li><li>千只鹤</li><li>雪国</li></ul><h3 id="马尔克斯">马尔克斯</h3><ul><li>霍乱时期的爱情</li><li>百年孤独</li></ul><h3 id="卡夫卡">卡夫卡</h3><ul><li>短篇小说集</li></ul><h3 id="乔治奥威尔">乔治·奥威尔</h3><ul><li>1984</li><li>动物庄园</li></ul><h3 id="博尔赫斯">博尔赫斯</h3><blockquote><p>怎么说呢，博尔赫斯的写作技法完全是反人类的......至少是反我的。崇尚短篇小说的博尔赫斯著作极其短小，不同于其他大家的著作------仿佛一条笔直的路，博尔赫斯的小说------仿佛一座蜿蜒曲折的迷宫，充斥着虚构历史和真实历史名词，引用繁多虚构的著作增添真实性，同时也更加晦涩难懂，更不用提时常参杂哲学思辨。这些错综复杂的写作技法，让阅读短短十几页的文字，犹如西天取经般漫长和困难重重。</p></blockquote><ul><li>小径分岔的花园</li><li>恶人列传</li><li>阿莱夫</li></ul><h3 id="司汤达">司汤达</h3><ul><li>红与黑</li></ul><h3 id="卢梭">卢梭</h3><blockquote><p>非常喜欢的一位思想家和文学家，文笔清新并不落俗套。即使卢梭并没有接受过正规教育，仍展现出敏锐的洞察力和深厚的文字功底，四十多岁凭借一篇《论科学与艺术是否有助于使社会风俗日趋淳朴》一鸣惊人，可谓是“是金子总会发光”的典范。</p></blockquote><ul><li>论科学与艺术</li><li>社会契约论</li><li>爱弥儿</li><li>一个孤独散步人的梦</li><li>忏悔录</li></ul><h3 id="夏目漱石">夏目漱石</h3><ul><li>我是猫</li></ul><h3 id="阿加莎克里斯蒂">阿加莎·克里斯蒂</h3><ul><li>尼罗河惨案</li><li>东方快车谋杀案</li><li>阳光下的罪恶</li></ul><h3 id="库切">库切</h3><ul><li>耻</li></ul><h3 id="索伦克尔凯郭尔">索伦·克尔凯郭尔</h3><ul><li>非此即彼</li><li>恐惧与战栗</li></ul>]]></content>
    
    
    <categories>
      
      <category>清单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>entertainment</tag>
      
      <tag>list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/05/01/%E6%9D%82%E9%A1%B9/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/01/%E6%9D%82%E9%A1%B9/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="init-a-git-repo">1 Init a git repo</h2><blockquote><p>参考链接: <a href="https://docs.microsoft.com/zh-cn/learn/modules/introduction-to-github/">msdn</a>(微软提供的github学习教程 )</p></blockquote><ol type="1"><li>init local repo <code>git init</code></li><li>create github repo</li><li>push your local repo to github repo <code>git push</code></li></ol><h2 id="trouble-shooting">2 Trouble shooting</h2><ol type="1"><li>Can't use <code>git push</code> from my terminal</li></ol><blockquote><p><a href="https://docs.github.com/en/authentication/troubleshooting-ssh/error-permission-denied-publickey">permission denied</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">generate ssh key</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">config ssh to github</a></p><p>os: config ssh and something other... daunt me really...</p></blockquote><h2 id="reference">3 Reference</h2><ol type="1"><li><a href="https://docs.github.com/en/get-started/using-git/about-git#basic-git-commands">about git</a>(github上对git的介绍)</li><li><a href="https://git-scm.com/docs">git-reference</a>(git官网命令行参考手册 os: 我就看了几分钟，啃不动硌牙)</li><li><a href="https://git-scm.com/book/en/v2">Pro Git</a>(很详细的官方推荐书籍，只用看前几章就可以了 os: 这个倒可以花时间认真看看，写得不错)</li></ol><h2 id="git-learning-notes">4 Git learning notes</h2><blockquote><p>因为git版本更新具有backward compatibility，所以很多指令的功能有所重叠，建议选择最直观常用的指令记忆</p></blockquote><h3 id="针对repo开发的常规指令">针对repo开发的常规指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs command">git add<br>git commit [-m] [-a]<br>git diff [--staged]<br>git status [--short]<br>git rm [-f] [--cache](--cache指明从staged area删除该文件但不从working directory删除文件)<br>git mv (用来对文件进行重命名)<br></code></pre></td></tr></table></figure><h3 id="针对repo配置的指令">针对repo配置的指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs command">git init<br>git clone<br>git config<br>git push<br></code></pre></td></tr></table></figure><h3 id="显示repo开发记录log">显示repo开发记录(log)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs command">git log [--patch] [--stat] <br>[--pretty=oneline(short/full/fuller/format:&quot;%h - %an, %ar : %s&quot;)] <br>[--graph] [-&lt;n&gt;](e.g. -2) [--since=2.weeks] [--until=] [--auther] [--grep] <br>[-S &lt;string&gt;] (pickax option, 用来显示指定字符串次数改变的commit os: 建议通过实例理解) <br>[-- &lt;path&gt;] (重要，用于显示路径文件或文件夹更改过的commit)<br><br>e.g.<br>For example, if you want to see which commits modifying test files in the Git source code history were committed by Junio Hamano in the month of October 2008 and are not merge commits, you can run something like this:<br>git log --pretty=&quot;%h - %s&quot; --author=&#x27;Junio C Hamano&#x27; --since=&quot;2008-10-01&quot; \<br>   --before=&quot;2008-11-01&quot; --no-merges -- t/<br></code></pre></td></tr></table></figure><h3 id="进行repo操作回退">进行repo操作回退</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs command">git commit [--amend] (对上次commit进行修补工作)<br>git restore(对working directory进行恢复) [--staged](对staged area进行恢复)<br></code></pre></td></tr></table></figure><h3 id="远程repo协作remote">远程repo协作(remote)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs command">git remote [-v] (显示URLs)<br>git remote add &lt;shortname&gt; &lt;url&gt;<br>git fetch &lt;remote&gt;<br>git pull (在fetch基础上进行merge, 如果pull.febase变量没有设定则会给出警告)<br>git config --global pull.rebase &quot;true&quot; (pulling时进行rebase)<br>git push &lt;remote&gt; &lt;branch&gt; (如果和别人同时clone后而别人先push的话你再push就会被reject, 你需要fetch后incorporate别人代码后再push)<br><br>git remote show &lt;remote&gt;<br>git remote rename &lt;remote&gt; &lt;new_remote&gt;<br>git remote remove &lt;remote&gt;<br></code></pre></td></tr></table></figure><h3 id="git-tricks">git tricks</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git config <span class="hljs-params">--global</span> <span class="hljs-keyword">alias</span>.&lt;<span class="hljs-keyword">alias</span>&gt; &lt;<span class="hljs-keyword">command</span>&gt;<br></code></pre></td></tr></table></figure><p>(e.g. git config --global alias.st status, you can type <code>git last</code> instead <code>git 'git log -1 HEAD'</code>)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config -<span class="hljs-keyword">global</span> credential.helper <span class="hljs-keyword">cache</span><br></code></pre></td></tr></table></figure><p>(using HTTPS URL to push and don't wanna to type password everytime, see more in <a href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage#_credential_caching">credential storage</a>)</p><h3 id="git-branch-management">git branch management</h3><ul><li>branching model</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs command">-git branch &lt;branch&gt; (create a new branch)<br>git branch -d &lt;branch&gt; (delete a branch)<br><br>git checkout &lt;branch&gt; (switch to a new branch)<br>git checkout -b &lt;branch&gt; (create and switch to a new branch)<br><br>git log --oneline --decorate --graph --all (paint a tree with all branches. os: cool!!!)<br><br>git switch [-c/--create]  &lt;branch&gt;<br>git swtich - (switch to previous branch)<br><br>git merge &lt;branch&gt; (e.g. git check out master | git merge hotfix)<br>git merge --abort (abort the merge)<br>git mergetool (graphical tool to resolve issues)<br></code></pre></td></tr></table></figure><ul><li>useful command</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs command">git branch [-v] (list all exiting branches) [-all] (including remote branches)<br>git branch [--merged/--no_merged]<br>git branch --move &lt;old_branch_name&gt; &lt;new_branch_name&gt; (change the name of branch)<br>git push --set-upstream origin &lt;new_branch_name&gt; (push new/rename branch to remote)<br>git push &lt;origin&gt; --delete &lt;branch&gt;<br></code></pre></td></tr></table></figure><ul><li>branching workflow</li></ul><ol type="1"><li>Longing-Running Branches (A long commits with multiple branches in different stages) </li><li>Topic Branches </li></ol><ul><li>remote branches</li></ul><p>branches name like <code>origin/main</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs command">git fetch &lt;remote&gt; (get remote database without omit)<br>git push &lt;remote&gt; &lt;branch&gt;:&lt;branch_newname&gt; (&#x27;:&#x27;以及后面部分可省略)<br>git merge &lt;remote/branch&gt; (merge remote work to current working branch)<br>git checkout -b &lt;branch&gt; &lt;remote/branch&gt; (create a new branch that you can work on)<br>git checkout --track &lt;remote/branch&gt; (shorhand of the previous command)<br>git checkout &lt;branch&gt; (shorhand of the previous command when branch (a)doesn&#x27;t exit (b)match a name on only one remote)<br>git branch [-u | --set-upstream-to] &lt;remote/branch&gt; (set current working branch to track remote branch)<br>git branch -vv (show local branches and the remote branches they track)<br><br>upstream shorthand: @&#123;upstream&#125; | @&#123;u&#125;<br></code></pre></td></tr></table></figure><ul><li>配合服务器使用的一些常用命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard  //撤销工作区与缓冲区所有修改, 并将工作区恢复至最后一次commit状态<br></code></pre></td></tr></table></figure><h3 id="problems-to-be-solved">problems to be solved</h3><ol type="1"><li>what's the meaning of <code>refs/heads</code> <a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain#ch10-git-internals">Git internals</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过hexo建立个人博客</title>
    <link href="/2022/05/01/%E6%9D%82%E9%A1%B9/%E9%80%9A%E8%BF%87hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/05/01/%E6%9D%82%E9%A1%B9/%E9%80%9A%E8%BF%87hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装hexo">1 安装hexo</h2><h3 id="依赖">1.1 依赖</h3><ul><li>git</li><li>node.js</li></ul><h3 id="安装">1.2 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h2 id="使用hexo">2 使用hexo</h2><h3 id="初始化相关文件">2.1 初始化相关文件</h3><p>在指定<code>&lt;floder&gt;</code>初始化博客系统相关文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></td></tr></table></figure><h3 id="更新相关文件并启动项目的命令">2.2 更新相关文件并启动项目的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br>hexo clean<br><br><span class="hljs-comment">#构建生成的页面的相关的内容</span><br>hexo g<br><br><span class="hljs-comment"># 项目启动</span><br>hexo s<br><br><span class="hljs-comment">#简写</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h2 id="安装主题">3 安装主题</h2><h3 id="安装-1">3.1 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>在根目录下新建<code>_config.fluid.yml</code>文件，并复制<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">文件</a>内容到新建的文件中</p><h3 id="配置">3.2 配置</h3><p>修改根目录下<code>config.yml</code>文件内以下配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yam">theme: fluid  # 指定主题<br><br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><h3 id="初始化关于页面">3.3 初始化「关于」页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p>修改<code>source/about/index.md</code>添加以下配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mark">---<br>title: 标题<br>layout: about<br>---<br></code></pre></td></tr></table></figure><h2 id="云端部署">4 云端部署</h2><blockquote><p><a href="https://blog.csdn.net/qq_38157825/article/details/112783631">参考链接</a>，部署至gitee</p></blockquote><ul><li><p>新建仓库</p></li><li><p>新建密钥</p></li><li><p>测试连接</p></li><li><p>添加公钥</p></li><li><p>配置<code>_config.yml</code></p></li><li><p>安装<code>hexo-deployer-git</code></p></li><li><p>推送命令<code>hexo g -d</code></p></li><li><p>开启gitee pages</p></li></ul><h2 id="显示图片">5 显示图片</h2><p>修改_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>下载hero-image-link插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-image-link --save<br></code></pre></td></tr></table></figure><p>修改图片路径</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">pic</span>](<span class="hljs-link">file-name/image-name.jpg</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意图片放在和md文件同名的文件夹下</p></blockquote><h2 id="显示公式">6 显示公式</h2><p>修改主题配置文件(在本文中为<code>_config.fluid.yml</code>)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br><span class="hljs-attr">math:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><span class="hljs-comment">#只有md文件front-matter（文件头部信息）里指定math: true时才会启动公式转换(加速处理)</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><p>更换公式渲染器（hexo原渲染器不支持复杂公式渲染）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<span class="hljs-comment">#卸载原渲染器</span><br>npm install hexo-renderer-pandoc --save<span class="hljs-comment">#需要安装Pandoc</span><br></code></pre></td></tr></table></figure><h2 id="常规使用">7 常规使用</h2><ul><li><p>md文件放于source/_post文件夹下</p></li><li><p>文件头部信息格式如下</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 使用Hexo搭建博客（基础版）<br>date: 2022-04-30 <br>categories:<br><span class="hljs-bullet">    -</span> 工具（父分类）<br><span class="hljs-bullet">    -</span> 博客搭建（子分类）<br>tags:<br><span class="hljs-bullet">    -</span> node<br><span class="hljs-section">math: true</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><ul><li>常用指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#本地构建预览</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br><br><span class="hljs-comment">#发布</span><br>hexo d<br></code></pre></td></tr></table></figure><ul><li>隐藏文件</li></ul><p>在md文件头部信息中加入以下配置项</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><span class="hljs-section">hide: true</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua学习</title>
    <link href="/2022/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/01/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="what-is-embedded-scripting-language">What is embedded scripting language?</h2><ul><li><a href="https://stackoverflow.com/questions/12042955/what-is-an-embedded-scripting-language">stackoverflow上的回答</a></li></ul><h2 id="command-line">Command line</h2><ul><li>lua -i prog.lua (enter interactive mode after execuating prog.lua)</li><li>dofile("prog.lua") (execuate prog.lua in interactive mode)</li><li>lua -e "print(19)" (execuate code in command line)</li></ul><h2 id="trick">Trick</h2><ul><li>Long comment <code>--[[  comment  ]]</code></li></ul><h2 id="reference">Reference</h2><ul><li><p><a href="https://github.com/dbohdan/embedded-scripting-languages">embedded scripting languages list</a></p></li><li><p><a href="https://stackoverflow.com/questions/1065584/what-is-data-driven-programming">data driven programming 1</a></p></li><li><p><a href="https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch09s01.html">data driven programming 2</a></p></li><li><p><a href="https://www.paragoncorporation.com/ArticleDetail.aspx?ArticleID=31">different between table/data driven programming</a></p></li></ul><h2 id="questions">Questions</h2><ol type="1"><li><blockquote><p>I reserve the identifier _ (a single underscore) for <strong>dummy variables</strong>.</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
